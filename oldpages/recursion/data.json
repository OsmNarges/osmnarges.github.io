{"nodes":[{"label":"sooriamurthi r. (2001)","x":29.792760848999023,"y":115.85710144042969,"id":"22","attributes":{"cluster":"4","weight\u003clinks\u003e":"1.0","weight\u003cnorm._citations\u003e":"1.0714","score\u003ccitations\u003e":"21.0","Component ID":"1","Cluter-ID":"4","description":"\u003ctable\u003e\u003ctr\u003e\u003ctd\u003eAuthors:\u003c/td\u003e\u003ctd\u003esooriamurthi r.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eTitle:\u003c/td\u003e\u003ctd\u003eproblems in comprehending recursion and suggested solutions\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eSource:\u003c/td\u003e\u003ctd\u003eproceedings of the conference on integrating technology into computer science education, iticse, 25-28\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eYear:\u003c/td\u003e\u003ctd\u003e2001\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e","abstract":"Recursion is a very powerful and useful problem solving strategy. But, along with pointers and dynamic data structures, many beginning programmers consider recursion to be a difficult concept to master. This paper reports on a study of upper-division undergraduate students on their difficulty in comprehending the ideas behind recursion. Three issues emerged as the points of difficulty for the students: (1) insufficient exposure to declarative thinking in a programming context (2) inadequate appreciation of the concept of functional abstraction (3) lack of a proper methodology to express a recursive solution. The paper concludes with a discussion of our approach to teaching recursion, which addresses these issues. Classroom experience indicates this approach effectively aids students\u0027 comprehension of recursion.","weight\u003ccitations\u003e":"21.0","url":"https://doi.org/10.1145/377435.377458","score\u003cpub._year\u003e":"2001.0","score\u003cnorm._citations\u003e":"1.0714"},"color":"rgb(255,112,69)","size":10.0},{"label":"ginat d. (1999a)","x":231.9573211669922,"y":-59.838340759277344,"id":"24","attributes":{"cluster":"3","weight\u003clinks\u003e":"1.0","weight\u003cnorm._citations\u003e":"0.9655","score\u003ccitations\u003e":"7.0","Component ID":"1","Cluter-ID":"1","description":"\u003ctable\u003e\u003ctr\u003e\u003ctd\u003eAuthors:\u003c/td\u003e\u003ctd\u003eginat d.; shifroni e.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eTitle:\u003c/td\u003e\u003ctd\u003eteaching recursion in a procedural environment - how much should we emphasize the computing model?\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eSource:\u003c/td\u003e\u003ctd\u003esigcse 1999 - proceedings of the 13th sigcse technical symposium on computer science education, 127-131\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eYear:\u003c/td\u003e\u003ctd\u003e1999\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e","abstract":"Recursion is a powerful and essential computational problem solving tool, but the concept of recursion is difficult to comprehend. Students that master the conventional programming construct of iteration in procedural programming environments, find it hard to utilize recursion. This study started as a test of CS College students\u0027 utilization of recursion. It was conducted after they have completed CS1, where they studied recursion with the C programming language. The test revealed that students adhere to the iterative pattern of \"forward accumulation\", due to their confidence with the iteration construct, but lack of trust of the recursion mechanism. These results motivated us to get more insight into the nature of recursion difficulties and ways to overcome them. In this paper we describe the difficulties we observed, and present a declarative, abstract, approach that contributed to overcome them. We question the emphasis that should be put on the basic computing model when presenting recursion, and argue for emphasis on the declarative approach for teaching recursion formulation in a procedural programming environment.","weight\u003ccitations\u003e":"7.0","score\u003cpub._year\u003e":"1999.0","score\u003cnorm._citations\u003e":"0.9655"},"color":"rgb(217,125,216)","size":10.0},{"label":"gegg-harrison t.s. (1991)","x":27.181238174438477,"y":364.4629211425781,"id":"29","attributes":{"cluster":"9","weight\u003clinks\u003e":"1.0","weight\u003cnorm._citations\u003e":"4.0625","score\u003ccitations\u003e":"26.0","Component ID":"1","Cluter-ID":"2","description":"\u003ctable\u003e\u003ctr\u003e\u003ctd\u003eAuthors:\u003c/td\u003e\u003ctd\u003egegg-harrison t.s.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eTitle:\u003c/td\u003e\u003ctd\u003elearning prolog in a schema-based environment\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eSource:\u003c/td\u003e\u003ctd\u003einstructional science, 20(2-3), 173-192\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eYear:\u003c/td\u003e\u003ctd\u003e1991\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e","abstract":"A set of basic construct Prolog schemata are presented as the basic constructs of a structured Prolog for recursive list processing. Prolog schema hierarchies are given that group classes of Prolog programs within each of the basic construct Prolog schemata via most-specific schemata which high-light their similarities and differences. A schema-based instructional approach based upon this classification of Prolog programs is provided as a method of introducing recursion to novice Prolog programmers. The incorporation of this approach to teaching recursive Prolog programming in an intelligent tutoring system is presented. Finally, a schema-based Prolog programming environment embedding this tutoring system in addition to a standard Prolog development system is proposed which promotes the acquisition and use of structured programming constructs in Prolog. © 1991 Kluwer Academic Publishers.","weight\u003ccitations\u003e":"26.0","url":"https://doi.org/10.1007/bf00120881","score\u003cpub._year\u003e":"1991.0","score\u003cnorm._citations\u003e":"4.0625"},"color":"rgb(35,150,111)","size":10.0},{"label":"mccauley r. (2015a)","x":-82.1678695678711,"y":-73.60465240478516,"id":"11","attributes":{"cluster":"1","weight\u003clinks\u003e":"6.0","weight\u003cnorm._citations\u003e":"2.0455","score\u003ccitations\u003e":"15.0","Component ID":"1","Cluter-ID":"0","description":"\u003ctable\u003e\u003ctr\u003e\u003ctd\u003eAuthors:\u003c/td\u003e\u003ctd\u003emccauley r.; grissom s.; fitzgerald s.; murphy l.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eTitle:\u003c/td\u003e\u003ctd\u003eteaching and learning recursive programming: a review of the research literature\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eSource:\u003c/td\u003e\u003ctd\u003ecomputer science education, 25(1), 37-66\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eYear:\u003c/td\u003e\u003ctd\u003e2015\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e","abstract":"Hundreds of articles have been published on the topics of teaching and learning recursion, yet fewer than 50 of them have published research results. This article surveys the computing education research literature and presents findings on challenges students encounter in learning recursion, mental models students develop as they learn recursion, and best practices in introducing recursion. Effective strategies for introducing the topic include using different contexts such as recurrence relations, programming examples, fractal images, and a description of how recursive methods are processed using a call stack. Several studies compared the efficacy of introducing iteration before recursion and vice versa. The paper concludes with suggestions for future research into how students learn and understand recursion, including a look at the possible impact of instructor attitude and newer pedagogies. © 2015 Taylor \u0026 Francis.","weight\u003ccitations\u003e":"15.0","url":"https://doi.org/10.1080/08993408.2015.1033205","score\u003cpub._year\u003e":"2015.0","score\u003cnorm._citations\u003e":"2.0455"},"color":"rgb(140,185,0)","size":10.0},{"label":"wilcocks d. (1994)","x":168.47637939453125,"y":-59.09695816040039,"id":"28","attributes":{"cluster":"3","weight\u003clinks\u003e":"11.0","weight\u003cnorm._citations\u003e":"2.6087","score\u003ccitations\u003e":"40.0","Component ID":"1","Cluter-ID":"1","description":"\u003ctable\u003e\u003ctr\u003e\u003ctd\u003eAuthors:\u003c/td\u003e\u003ctd\u003ewilcocks d.; sanders i.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eTitle:\u003c/td\u003e\u003ctd\u003eanimating recursion as an aid to instruction\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eSource:\u003c/td\u003e\u003ctd\u003ecomputers and education, 23(3), 221-226\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eYear:\u003c/td\u003e\u003ctd\u003e1994\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e","abstract":"This paper presents a method for overcoming one of the most difficult problems in teaching programming to first-year university students, namely recursion. It is established that what is required to understand recursion is an abstracted mental model of recursive flow of control. The model which is deemed most suitable for the purposes of this research is the copies model of recursion. In this model recursive instantiations are seen as copies of the recursive function. In order to present this model to students, a program (as opposed to data or algorithm) animator is employed. This animator takes any Pascal program containing a recursive function and presents the student with a dynamic copies model of the recursive function. © 1994, Elsevier Science Ltd. All rights reserved.","weight\u003ccitations\u003e":"40.0","url":"https://doi.org/10.1016/s0360-1315(05)80013-2","score\u003cpub._year\u003e":"1994.0","score\u003cnorm._citations\u003e":"2.6087"},"color":"rgb(217,125,216)","size":10.0},{"label":"ginat d. (1999b)","x":48.167236328125,"y":-171.98194885253906,"id":"25","attributes":{"cluster":"1","weight\u003clinks\u003e":"5.0","weight\u003cnorm._citations\u003e":"2.8966","score\u003ccitations\u003e":"21.0","Component ID":"1","Cluter-ID":"0","description":"\u003ctable\u003e\u003ctr\u003e\u003ctd\u003eAuthors:\u003c/td\u003e\u003ctd\u003eginat d.; shifroni e.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eTitle:\u003c/td\u003e\u003ctd\u003eteaching recursion in a procedural environment - how much should we emphasize the computing model?\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eSource:\u003c/td\u003e\u003ctd\u003esigcse bulletin (association for computing machinery, special interest group on computer science education), 31(1), 127-131\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eYear:\u003c/td\u003e\u003ctd\u003e1999\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e","abstract":"Recursion is a powerful and essential computational problem solving tool, but the concept of recursion is difficult to comprehend. Students that master the conventional programming construct of iteration in procedural programming environments, find it hard to utilize recursion. This study started as a test of CS College students\u0027 utilization of recursion. It was conducted after they have completed CS1, where they studied recursion with the C programming language. The test revealed that students adhere to the iterative pattern of \"forward accumulation\", due to their confidence with the iteration construct, but lack of trust of the recursion mechanism. These results motivated us to get more insight into the nature of recursion difficulties and ways to overcome them. In this paper we describe the difficulties we observed, and present a declarative, abstract, approach that contributed to overcome them. We question the emphasis that should be put on the basic computing model when presenting recursion, and argue for emphasis on the declarative approach for teaching recursion formulation in a procedural programming environment.","weight\u003ccitations\u003e":"21.0","url":"https://doi.org/10.1145/384266.299718","score\u003cpub._year\u003e":"1999.0","score\u003cnorm._citations\u003e":"2.8966"},"color":"rgb(140,185,0)","size":10.0},{"label":"haberman b. (2002)","x":148.8003387451172,"y":3.7673251628875732,"id":"20","attributes":{"cluster":"7","weight\u003clinks\u003e":"2.0","weight\u003cnorm._citations\u003e":"2.7273","score\u003ccitations\u003e":"24.0","Component ID":"1","Cluter-ID":"1","description":"\u003ctable\u003e\u003ctr\u003e\u003ctd\u003eAuthors:\u003c/td\u003e\u003ctd\u003ehaberman b.; averbuch h.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eTitle:\u003c/td\u003e\u003ctd\u003ethe case of base cases: why are they so difficult to recognize? student difficulties with recursion\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eSource:\u003c/td\u003e\u003ctd\u003eproceedings of the annual sigcse conference on innovation and technology in computer science education (itisce), 84-88\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eYear:\u003c/td\u003e\u003ctd\u003e2002\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e","abstract":"Recursion is a central concept in computer science, yet it is a very difficult concept for beginners to learn. In this paper we focus on a specific aspect of comprehending recursion - the conception of the base case as an integral component of a recursive algorithm. We found that students have difficulties in identifying base cases: they handle redundant base cases; ignore boundary values and degenerated cases; avoid out-of-range values; and may even not define any base cases when formulating recursive algorithms. We also found that students have difficulties in evaluating recursive algorithms that deal with imperceptible base cases. We suggest that teachers should make a special effort to discuss different aspects of the base case concept. Emphasis should be put on both declarative and procedural aspects of categorizing and handling base cases as part of recursion formulation.","weight\u003ccitations\u003e":"24.0","score\u003cpub._year\u003e":"2002.0","score\u003cnorm._citations\u003e":"2.7273"},"color":"rgb(217,125,216)","size":10.0},{"label":"tung s.-h. (2001)","x":179.84120178222656,"y":42.25570297241211,"id":"23","attributes":{"cluster":"8","weight\u003clinks\u003e":"4.0","weight\u003cnorm._citations\u003e":"0.4592","score\u003ccitations\u003e":"9.0","Component ID":"1","Cluter-ID":"1","description":"\u003ctable\u003e\u003ctr\u003e\u003ctd\u003eAuthors:\u003c/td\u003e\u003ctd\u003etung s.-h.; chang c.-t.; wong w.-k.; jehng j.-c.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eTitle:\u003c/td\u003e\u003ctd\u003evisual representations for recursion\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eSource:\u003c/td\u003e\u003ctd\u003einternational journal of human computer studies, 54(3), 285-300\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eYear:\u003c/td\u003e\u003ctd\u003e2001\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e","abstract":"Visualcode is a visual notation that uses coloured expressions and graphical environments to describe the execution of Scheme programs. RainbowScheme is a program visualization system which is designed to produce visualcode representations of step-by-step execution of Scheme programs. This article presents a new approach of teaching recursion using visualcode and RainbowScheme. Experimental evaluation indicates that viewing RainbowScheme-produced visual traces and requiring students to use visualcode to generate visual evaluation steps of recursive programs can enhance the learners\u0027 ability to evaluate recursive programs as well as to solve recursive programming problems. © 2001 Academic Press.","weight\u003ccitations\u003e":"9.0","url":"https://doi.org/10.1006/ijhc.2000.0433","score\u003cpub._year\u003e":"2001.0","score\u003cnorm._citations\u003e":"0.4592"},"color":"rgb(217,125,216)","size":10.0},{"label":"cabodi g. (2020)","x":-37.52498245239258,"y":-12.560945510864258,"id":"2","attributes":{"cluster":"1","weight\u003clinks\u003e":"2.0","weight\u003cnorm._citations\u003e":"1.125","score\u003ccitations\u003e":"1.0","Component ID":"1","Cluter-ID":"4","description":"\u003ctable\u003e\u003ctr\u003e\u003ctd\u003eAuthors:\u003c/td\u003e\u003ctd\u003ecabodi g.; camurati p.; pasini p.; patti d.; vendraminetto d.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eTitle:\u003c/td\u003e\u003ctd\u003eschema-based instruction with enumerative combinatorics and recursion to develop computer engineering students\u0027 problem-solving skills\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eSource:\u003c/td\u003e\u003ctd\u003einternational journal of engineering education, 36(5), 1505-1528\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eYear:\u003c/td\u003e\u003ctd\u003e2020\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e","abstract":"Learning and teaching problem solving is a hard task, no matter the domain. Computer Science is no exception. Recursion is a paradigm often used for problem solving, but it is non-intuitive and it is unnatural. Most second programming courses (CS2-level) for Computer Engineering students apply recursion to mathematical problems or basic recursive data structures with a limited focus on problem solving. Third programming courses (CS3-level) deal with search and optimization problems and they use recursion because of its ability, due to its backtracking mechanism, to explore the whole solution space. However, most of them do not rely on a systematic and well-formed approach to teaching this approach to problem solving. Our main contribution is to adopt schema-based instruction for recursion-based problem solving, where schemas come from Enumerative Combinatorics. This is the core of our attempt at developing second-year computer Engineering students\u0027 problem-solving skills. We provide the students with these schemas as templates in the C language to guide them step-by-step in solving search and optimization problems with uninformed and complete algorithms. To extend the applicability of this approach to other than small-size problems, we show students how they can introduce pruning to limit search while keeping it complete. We present experimental evidence we gathered for our second-year CS2+CS3 programming course for Computer Engineering students at Politecnico di Torino, a major technical university in Italy. We evaluate students\u0027 perception of the approach in terms of understanding and of ability to apply it. We compare students\u0027 perception to faculty expectations and we evaluate students\u0027 performance in terms of improvement in the success rate at exams. Data prove that the approach we adopt is beneficial both in terms of quantitative results (success rate at exams) and qualitative results (knowledge and skills acquired by students). © 2020 TEMPUS Publications.","weight\u003ccitations\u003e":"1.0","score\u003cpub._year\u003e":"2020.0","score\u003cnorm._citations\u003e":"1.125"},"color":"rgb(255,112,69)","size":10.0},{"label":"grissom s. (2016)","x":-82.18006134033203,"y":29.684043884277344,"id":"9","attributes":{"cluster":"2","weight\u003clinks\u003e":"2.0","weight\u003cnorm._citations\u003e":"1.3433","score\u003ccitations\u003e":"10.0","Component ID":"1","Cluter-ID":"0","description":"\u003ctable\u003e\u003ctr\u003e\u003ctd\u003eAuthors:\u003c/td\u003e\u003ctd\u003egrissom s.; mccauley r.; murphy l.; fitzgerald s.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eTitle:\u003c/td\u003e\u003ctd\u003epaper vs. computer-based exams: a study of errors in recursive binary tree algorithms\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eSource:\u003c/td\u003e\u003ctd\u003esigcse 2016 - proceedings of the 47th acm technical symposium on computing science education, 6-11\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eYear:\u003c/td\u003e\u003ctd\u003e2016\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e","abstract":"This paper reports on a study of goal-plans and errors produced by students who wrote recursive solutions for a binary tree operation. This work extends a previous study of difficulties CS2 students experienced while writing solutions on paper-based exams. In this study, participants solved the same recursive binary tree problem as part of a hands-on computer-based exam where students had access to an IDE and Java API documentation. Not surprisingly, students who took the computer-based exams were more successful than those who took the paper-based exams (58% vs. 17% correct solutions). However, even with the advantage of access to an IDE, documentation, and test cases, 42% of students taking the computer-based exam still made errors, indicating that students exhibit persistent errors even with support. The most common errors observed included incorrect calculations, missing method calls and missing and incorrect base cases. © 2016 ACM.","weight\u003ccitations\u003e":"10.0","url":"https://doi.org/10.1145/2839509.2844587","score\u003cpub._year\u003e":"2016.0","score\u003cnorm._citations\u003e":"1.3433"},"color":"rgb(140,185,0)","size":10.0},{"label":"lacave c. (2018)","x":95.84648132324219,"y":50.54362106323242,"id":"5","attributes":{"cluster":"7","weight\u003clinks\u003e":"3.0","weight\u003cnorm._citations\u003e":"1.2787","score\u003ccitations\u003e":"6.0","Component ID":"1","Cluter-ID":"1","description":"\u003ctable\u003e\u003ctr\u003e\u003ctd\u003eAuthors:\u003c/td\u003e\u003ctd\u003elacave c.; molina a.i.; redondo m.a.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eTitle:\u003c/td\u003e\u003ctd\u003ea preliminary instrument for measuring students\u0027 subjective perceptions of difficulties in learning recursion\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eSource:\u003c/td\u003e\u003ctd\u003eieee transactions on education, 61(2), 119-126\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eYear:\u003c/td\u003e\u003ctd\u003e2018\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e","abstract":"Contribution: Findings are provided from an initial survey to evaluate the magnitude of the recursion problem from the student point of view.Background: A major difficulty that programming students must overcome - the learning of recursion - has been addressed by many authors, using various approaches, but none have considered how students perceive this issue.Research Questions: 1) How can an instrument be developed to characterize the main difficulties students encounter, from their subjective perspective, when learning recursion? and 2) How can the quality of the developed instrument be determined?Methodology: 1) A development process was followed to create the instrument. This process included justification of the content, and a quality analysis of the instrument in terms of validity and reliability and 2) the study was on a limited number of students, so should be regarded as preliminary with respect to validity and reliability of results.Findings: 1) An initial survey indicates the magnitude of the recursion problem from the students\u0027 point of view; 2) students\u0027 perception is that neither motivation, nor their previous knowledge of theoretical concepts on recursion, are factors that affect their learning of the recursion process; and 3) for further statistical analysis, data from a simplified survey proved more valid and more reliable than that from the original survey, for the study sample examined. © 1963-2012 IEEE.","weight\u003ccitations\u003e":"6.0","url":"https://doi.org/10.1109/te.2017.2758346","score\u003cpub._year\u003e":"2018.0","score\u003cnorm._citations\u003e":"1.2787"},"color":"rgb(217,125,216)","size":10.0},{"label":"wiedenbeek s. (1988)","x":-229.8647003173828,"y":123.35330963134766,"id":"34","attributes":{"cluster":"5","weight\u003clinks\u003e":"1.0","weight\u003cnorm._citations\u003e":"0.0","score\u003ccitations\u003e":"0.0","Component ID":"1","Cluter-ID":"3","description":"\u003ctable\u003e\u003ctr\u003e\u003ctd\u003eAuthors:\u003c/td\u003e\u003ctd\u003ewiedenbeek s.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eTitle:\u003c/td\u003e\u003ctd\u003elearning recursion as a concept and as a programming technique\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eSource:\u003c/td\u003e\u003ctd\u003eproceedings of the 19th sigcse technical symposium on computer science education, sigcse 1988, 275-278\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eYear:\u003c/td\u003e\u003ctd\u003e1988\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e","abstract":"Two experiments on learning recursion and iteration were carried out. The first studied learning of the mathematical concept of recursion by having subjects compute mathematical functions by analogy to worked out examples. The results suggest that subjects are quite able to induce a computational procedure for both iterative and recursive functions from examples. Furthermore, prior practice with iterative examples does not seem to facilitate subsequent performance on similar recursive problems, nor does prior practice with recursive examples facilitate performance on iterative problems. The second experiment studied novice subjects\u0027 comprehension of iterative and recursive Pascal programs. Comprehension of the iterative program was not improved by prior exposure to the recursive version of the program. Comprehension of the recursive version was improved moderately by prior work with the iterative version. © 1988 ACM.","weight\u003ccitations\u003e":"0.0","url":"https://doi.org/10.1145/52964.53033","score\u003cpub._year\u003e":"1988.0","score\u003cnorm._citations\u003e":"0.0"},"color":"rgb(0,199,255)","size":10.0},{"label":"kessler c.m. (1986)","x":-195.83204650878906,"y":76.75946807861328,"id":"35","attributes":{"cluster":"5","weight\u003clinks\u003e":"6.0","weight\u003cnorm._citations\u003e":"1.0","score\u003ccitations\u003e":"33.0","Component ID":"1","Cluter-ID":"3","description":"\u003ctable\u003e\u003ctr\u003e\u003ctd\u003eAuthors:\u003c/td\u003e\u003ctd\u003ekessler c.m.; anderson j.r.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eTitle:\u003c/td\u003e\u003ctd\u003elearning flow of control: recursive and iterative procedures\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eSource:\u003c/td\u003e\u003ctd\u003ehuman-computer interaction, 2(2), 135-166\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eYear:\u003c/td\u003e\u003ctd\u003e1986\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e","abstract":"Two experiments were performed to study students’ ability to write recursive and iterative programs and transfer between these two skills. Subjects wrote functions to accumulate instances into a list. Problems varied in terms of whether they were recursive or iterative, whether they operated on lists or numbers, whether they accumulated results in forward or backward manner, whether they accumulated on success or failure, and whether they simply skipped or ejected on failure to accumulate. Subjects had real difficulty only with the dimensions concerned with flow of control, namely, recursive versus iterative, and skip versus eject. We found positive transfer from writing iterative functions to writing recursive functions, but not vice versa. A subsequent protocol study revealed subjects had such a poor mental model of recursion that they developed poor learning strategies which hindered their understanding of iteration. It is argued that having an adequate model of the functionality of programming is prerequisite to learning to program, and that it is sensible pedagogical practice to base understanding of recursive flow of control on understanding iterative flow of control. © 1986, Taylor \u0026 Francis Group, LLC. All rights reserved.","weight\u003ccitations\u003e":"33.0","url":"https://doi.org/10.1207/s15327051hci0202_2","score\u003cpub._year\u003e":"1986.0","score\u003cnorm._citations\u003e":"1.0"},"color":"rgb(0,199,255)","size":10.0},{"label":"sanders i. (2007)","x":202.36778259277344,"y":-111.9937973022461,"id":"18","attributes":{"cluster":"3","weight\u003clinks\u003e":"1.0","weight\u003cnorm._citations\u003e":"0.2545","score\u003ccitations\u003e":"2.0","Component ID":"1","Cluter-ID":"1","description":"\u003ctable\u003e\u003ctr\u003e\u003ctd\u003eAuthors:\u003c/td\u003e\u003ctd\u003esanders i.; galpin v.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eTitle:\u003c/td\u003e\u003ctd\u003estudents\u0027 mental models of recursion at wits\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eSource:\u003c/td\u003e\u003ctd\u003eiticse 2007: 12th annual conference on innovation and technology in computer science education - inclusive education in computer science, 317\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eYear:\u003c/td\u003e\u003ctd\u003e2007\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e","abstract":"Recursion is a concept which all computer scientists should understand and be able to use but novices find it difficult to master. In the School of Computer Science at the University of the Witwatersrand (Wits) we have for a long time been concerned about how we can assist our students with recursion [4, 1, 3]. One thrust of our research is the study of the mental models of recursion (c.f. Kahney [2]) which our first year students develop. Most of our students encounter recursion for the first time in our Fundamental Algorithmic Concepts (FAC) course. When we originally investigated the mental models of our students we noted that although many of them seem to develop the viable copies model there are still many that develop models which are non-viable (i.e. that cannot be relied on to lead to a correct result) [1]. Thus we adapted the way in which recursion was introduced in FAC in 2003, 2004 and 2005 by introducing more complex recursive algorithms earlier to help in the development of the copies mental model. We then compared the mental models developed by the 2003, 2004 and 2005 students to those developed by the earlier group [3]. The results indicate that more of the students were developing viable mental models of recursion and thus that the changes to our teaching were benefitting our students. In 2006 we changed the programing language in which our students implement algorithms to Python (from Scheme). In essence the programming language was the only change made as the course was still taught in a \"functional\" style to emphasize the link between the formal specification of a problem, the solution to the problem and the program. We did, however, feel it was important to assess the impact of the change on our students\u0027 mental models of recursion. We thus did a similar study on the 2006 students to that on earlier cohorts. The students\u0027 traces from two recursive algorithms were categorised into the mental models previously observed [1, 3] by identifying how the student deals with the active flow, base case and passive flow in their trace and then by combining this information into an overall categorisation of the trace for that algorithm . Overall the results are in line with our previous results which showed that the copies model is the dominant model for a recurrence relation type of recursive function but that for list manipulation problems some students showed an active or looping model. These results indicate that our teaching approach, even with the switch to Python, is assisting our students in developing a viable copies mental model of recursion. Such a mental model is more likely to lead to correct traces of recursive algorithms. An interesting new result was the emergence of a passive mental model. Here the students recognised that the recursive algorithm would somehow get to the base case and then used the base case plus the implicit definition of the function in the algorithm to build up the required solution. This model may have arisen because the students were given a recurrence in Tutorial 1 and asked to calculate what value would be returned. Solving the recurrence essentially meant working up from the value where the result is defined directly until the desired answer is found. Some students may have adopted this as their model of recursion.","weight\u003ccitations\u003e":"2.0","url":"https://doi.org/10.1145/1268784.1268883","score\u003cpub._year\u003e":"2007.0","score\u003cnorm._citations\u003e":"0.2545"},"color":"rgb(217,125,216)","size":10.0},{"label":"give\u0027on y.s. (1991)","x":-20.834680557250977,"y":116.55638885498047,"id":"30","attributes":{"cluster":"4","weight\u003clinks\u003e":"1.0","weight\u003cnorm._citations\u003e":"0.9375","score\u003ccitations\u003e":"6.0","Component ID":"1","Cluter-ID":"4","description":"\u003ctable\u003e\u003ctr\u003e\u003ctd\u003eAuthors:\u003c/td\u003e\u003ctd\u003egive\u0027on y.s.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eTitle:\u003c/td\u003e\u003ctd\u003eteaching recursive programming using parallel multi-turtle graphics\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eSource:\u003c/td\u003e\u003ctd\u003ecomputers and education, 16(3), 267-280\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eYear:\u003c/td\u003e\u003ctd\u003e1991\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e","abstract":"A general heuristic scheme for programming of recursive patterns in multi-turtle environments is presented in this paper. It is offered here for its own sake as well as a tool for teaching recursion to high school students of Computer Science (or Informatics) and to teacher training students of Computer Science Teaching. This scheme is relatively simple, when compared in terms of requirements and results with recursive programming of the same patterns in single-turtle environments. Furthermore, when applied to all recursive graphic patterns used in teaching recursive programming, this scheme yields simple recursive programs. Recursion in multi-turtle environments, when limited to those recursive graphic patterns, leads naturally to iterative programs. These results have some theoretical and educational implications that are further discussed in the paper. © 1991.","weight\u003ccitations\u003e":"6.0","url":"https://doi.org/10.1016/0360-1315(91)90061-u","score\u003cpub._year\u003e":"1991.0","score\u003cnorm._citations\u003e":"0.9375"},"color":"rgb(255,112,69)","size":10.0},{"label":"bruce k.b. (2005)","x":-185.7846221923828,"y":-299.3406982421875,"id":"19","attributes":{"cluster":"6","weight\u003clinks\u003e":"1.0","weight\u003cnorm._citations\u003e":"3.4375","score\u003ccitations\u003e":"11.0","Component ID":"1","Cluter-ID":"0","description":"\u003ctable\u003e\u003ctr\u003e\u003ctd\u003eAuthors:\u003c/td\u003e\u003ctd\u003ebruce k.b.; danyluk a.; murtagh t.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eTitle:\u003c/td\u003e\u003ctd\u003ewhy structural recursion should be taught before arrays in cs 1\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eSource:\u003c/td\u003e\u003ctd\u003eproceedings of the thirty-sixth sigcse technical symposium on computer science education, sigcse 2005, 246-250\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eYear:\u003c/td\u003e\u003ctd\u003e2005\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e","abstract":"The approach to teaching recursion in introductory programming courses has changed little during the transition from procedural to object-oriented languages. It is still common to present recursion late in the course and to focus on traditional, procedural examples such as calculating factorials or solving the Towers of Hanoi puzzle. In this paper, we propose that the shift to object-oriented programming techniques calls for a significant shift in our approach to teaching recursion. First, we argue that in the context of object-oriented programming students should be introduced to examples of simple recursive structures such as linked lists and methods that process them, before being introduced to traditional procedural examples. Second, we believe that this material should be presented before students are introduced to structures such as arrays. In our experience, the early presentation of recursive structures provides the opportunity to reinforce the fundamentals of defining and using classes and better prepares students to appreciate the reasons to use classes to encapsulate access to other data structures when they are presented. Copyright 2005 ACM.","weight\u003ccitations\u003e":"11.0","url":"https://doi.org/10.1145/1047344.1047430","score\u003cpub._year\u003e":"2005.0","score\u003cnorm._citations\u003e":"3.4375"},"color":"rgb(140,185,0)","size":10.0},{"label":"velazquez-iturbide j.a. (2016)","x":95.137451171875,"y":15.447155952453613,"id":"8","attributes":{"cluster":"7","weight\u003clinks\u003e":"3.0","weight\u003cnorm._citations\u003e":"0.2687","score\u003ccitations\u003e":"2.0","Component ID":"1","Cluter-ID":"1","description":"\u003ctable\u003e\u003ctr\u003e\u003ctd\u003eAuthors:\u003c/td\u003e\u003ctd\u003evelazquez-iturbide j.a.; castellanos m.e.; hijon-neira r.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eTitle:\u003c/td\u003e\u003ctd\u003erecursion removal as an instructional method to enhance the understanding of recursion tracing\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eSource:\u003c/td\u003e\u003ctd\u003eieee transactions on education, 59(3), 161-168\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eYear:\u003c/td\u003e\u003ctd\u003e2016\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e","abstract":"Recursion is one of the most difficult programming topics for students. In this paper, an instructional method is proposed to enhance students\u0027 understanding of recursion tracing. The proposal is based on the use of rules to translate linear recursion algorithms into equivalent, iterative ones. The paper has two main contributions: the instructional method itself, and its evaluation, which is based on previous works of other authors on mental models of recursion. As a result, an enhancement was measured in the viability of mental models exhibited by students (both for linear and multiple recursion), but no significant improvement was detected in their skills for designing recursive algorithms. Evidence was also obtained of the fact that many students with (relatively) viable mental models for linear recursion have unviable mental models for multiple recursion. Finally, it was noticed that many students adopt inaccurate mental models if those models are adequate to handle the given algorithm. © 2016 IEEE.","weight\u003ccitations\u003e":"2.0","url":"https://doi.org/10.1109/te.2015.2468682","score\u003cpub._year\u003e":"2016.0","score\u003cnorm._citations\u003e":"0.2687"},"color":"rgb(217,125,216)","size":10.0},{"label":"lee e. (2014)","x":122.30403900146484,"y":-145.7713165283203,"id":"13","attributes":{"cluster":"1","weight\u003clinks\u003e":"2.0","weight\u003cnorm._citations\u003e":"1.12","score\u003ccitations\u003e":"7.0","Component ID":"1","Cluter-ID":"1","description":"\u003ctable\u003e\u003ctr\u003e\u003ctd\u003eAuthors:\u003c/td\u003e\u003ctd\u003elee e.; shan v.; beth b.; lin c.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eTitle:\u003c/td\u003e\u003ctd\u003ea structured approach to teaching recursion using cargo-bot\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eSource:\u003c/td\u003e\u003ctd\u003eicer 2014 - proceedings of the 10th annual international conference on international computing education research, 60-66\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eYear:\u003c/td\u003e\u003ctd\u003e2014\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e","abstract":"Recursion is a notoriously difficult concept to learn. This paper presents a structured approach to teaching recursion that combines classroom lectures and self-paced interaction with Cargo-Bot, a video game in which users solve puzzles using a simple visual programming language. After mapping Cargo-Bot games to a set of learning goals, we devise a lesson plan that uses Cargo-Bot game playing to scaffold key concepts used in writing recursive Java programs. We empirically evaluate our approach using 204 undergraduates enrolled in a CS2 course, and we show strong statistical evidence that our approach improves student learning of recursion over traditional lecture-based instruction alone. Copyright © 2014 ACM.","weight\u003ccitations\u003e":"7.0","url":"https://doi.org/10.1145/2632320.2632356","score\u003cpub._year\u003e":"2014.0","score\u003cnorm._citations\u003e":"1.12"},"color":"rgb(217,125,216)","size":10.0},{"label":"mccauley r. (2015b)","x":-127.7325210571289,"y":58.2141227722168,"id":"12","attributes":{"cluster":"2","weight\u003clinks\u003e":"3.0","weight\u003cnorm._citations\u003e":"1.9091","score\u003ccitations\u003e":"14.0","Component ID":"1","Cluter-ID":"3","description":"\u003ctable\u003e\u003ctr\u003e\u003ctd\u003eAuthors:\u003c/td\u003e\u003ctd\u003emccauley r.; hanks b.; fitzgerald s.; murphy l.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eTitle:\u003c/td\u003e\u003ctd\u003erecursion vs. iteration: an empirical study of comprehension revisited\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eSource:\u003c/td\u003e\u003ctd\u003esigcse 2015 - proceedings of the 46th acm technical symposium on computer science education, 350-355\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eYear:\u003c/td\u003e\u003ctd\u003e2015\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e","abstract":"This study compares differences in students\u0027 ability to comprehend recursive and iterative programs by replicating a 1996 study. These studies are interesting for the following reasons: (1) there have been few studies on the comprehension of recursive programs, (2) there have been few studies of recursion that involve the use of data structures, (3) subjects were asked to read and comprehend code that manipulated linked lists recursively. In a 1996 study, subjects found a recursive version of a linked list search function easier to comprehend than an iterative version. The results of this study contradict these earlier findings; subjects in this study were equally likely to correctly describe the purpose of the search algorithm, regardless of iterative or recursive implementation. Consistent with the findings in the 1996 study, subjects in this study were more likely to correctly describe the copy task using the iterative version of this problem rather than the recursive version. Subjects who correctly described the purpose of the copy method wrote abstract summaries. Many of the subjects who did not recognize the purpose of the code, and who answered incorrectly, provided a line-by-line (partial) trace of the code. While revealing some understanding of the execution of the code, these subjects were generally not able to see the forest for the trees. Copyright © 2015 ACM.","weight\u003ccitations\u003e":"14.0","url":"https://doi.org/10.1145/2676723.2677227","score\u003cpub._year\u003e":"2015.0","score\u003cnorm._citations\u003e":"1.9091"},"color":"rgb(0,199,255)","size":10.0},{"label":"esteero r. (2018)","x":-109.31029510498047,"y":-165.77101135253906,"id":"6","attributes":{"cluster":"6","weight\u003clinks\u003e":"4.0","weight\u003cnorm._citations\u003e":"0.6393","score\u003ccitations\u003e":"3.0","Component ID":"1","Cluter-ID":"0","description":"\u003ctable\u003e\u003ctr\u003e\u003ctd\u003eAuthors:\u003c/td\u003e\u003ctd\u003eesteero r.; khan m.; mohamed m.; zhang l.y.; zingaro d.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eTitle:\u003c/td\u003e\u003ctd\u003erecursion or iteration: does it matter what students choose?\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eSource:\u003c/td\u003e\u003ctd\u003esigcse 2018 - proceedings of the 49th acm technical symposium on computer science education, 2018-january, 1011-1016\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eYear:\u003c/td\u003e\u003ctd\u003e2018\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e","abstract":"Recursion and iteration are two key topics taught in introductory Computer Science. This is especially so for CS2 students, as CS2 is the course where recursion is typically taught and where control-flow concepts are solidified. When asked to solve a problem that could feasibly be solved with recursion or iteration, what do CS2 students choose to do? And how does this choice relate to the correctness of their code? This paper provides one answer to these questions through an analysis of student exam responses to a problem on finding deepest common ancestors in trees. We find that 19% of students choose to use iteration, 51% choose recursion, and 16% choose to combine both iteration and recursion. In terms of correctness, we find that students who choose iteration perform better than those who choose recursion and the combination of both. Additionally, we find concern in the number of students who seemingly do not understand what the question is asking. We end the paper with some comments on helping students choose an appropriate control-flow strategy and a discussion of this type of question on a final exam. © 2018 Association for Computing Machinery.","weight\u003ccitations\u003e":"3.0","url":"https://doi.org/10.1145/3159450.3159455","score\u003cpub._year\u003e":"2018.0","score\u003cnorm._citations\u003e":"0.6393"},"color":"rgb(140,185,0)","size":10.0},{"label":"benander a.c. (1996)","x":-146.2601776123047,"y":-20.761842727661133,"id":"26","attributes":{"cluster":"2","weight\u003clinks\u003e":"5.0","weight\u003cnorm._citations\u003e":"2.4375","score\u003ccitations\u003e":"13.0","Component ID":"1","Cluter-ID":"0","description":"\u003ctable\u003e\u003ctr\u003e\u003ctd\u003eAuthors:\u003c/td\u003e\u003ctd\u003ebenander a.c.; benander b.a.; pu h.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eTitle:\u003c/td\u003e\u003ctd\u003erecursion vs. iteration: an empirical study of comprehension\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eSource:\u003c/td\u003e\u003ctd\u003ejournal of systems and software, 32(1), 73-82\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eYear:\u003c/td\u003e\u003ctd\u003e1996\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e","abstract":"An extensive study involving three test groups over a period of three different years was performed to determine differences between comprehension of recursive and iterative code constructs. This study involved computer science students enrolled in six different data structure classes using PASCAL and obtained 275 responses, which were statistically analyzed. Using a X2 test, one task - searching a linked list for a given value - showed a statistically significant (p \u003d 0.006) difference in comprehension favoring recursion. Another task - making a copy of a linked list - favored iteration, but not with statistical significance. Among responses with correct comprehension, a comparison of means test was performed on the comprehension times among the latter two groups in the study. There was a faster rate of comprehension of the recursive code for both of the tasks (p \u003d 0.096 for the search and p \u003d 0.045 for the copy). A two-way analysis of variance suggested a tendency toward an interaction effect between task and construct in terms of comprehension time.","weight\u003ccitations\u003e":"13.0","url":"https://doi.org/10.1016/0164-1212(95)00043-7","score\u003cpub._year\u003e":"1996.0","score\u003cnorm._citations\u003e":"2.4375"},"color":"rgb(140,185,0)","size":10.0},{"label":"rinderknecht c. (2014)","x":3.4425947666168213,"y":62.53886795043945,"id":"14","attributes":{"cluster":"4","weight\u003clinks\u003e":"13.0","weight\u003cnorm._citations\u003e":"2.4","score\u003ccitations\u003e":"15.0","Component ID":"1","Cluter-ID":"4","description":"\u003ctable\u003e\u003ctr\u003e\u003ctd\u003eAuthors:\u003c/td\u003e\u003ctd\u003erinderknecht c.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eTitle:\u003c/td\u003e\u003ctd\u003ea survey on teaching and learning recursive programming\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eSource:\u003c/td\u003e\u003ctd\u003einformatics in education, 13(1), 87-119\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eYear:\u003c/td\u003e\u003ctd\u003e2014\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e","abstract":"We survey the literature about the teaching and learning of recursive programming. After a short history of the advent of recursion in programming languages and its adoption by programmers, we present curricular approaches to recursion, including a review of textbooks and some programming methodology, as well as the functional and imperative paradigms and the distinction between control flow vs. data flow. We follow the researchers in stating the problem with base cases, noting the similarity with induction in mathematics, making concrete analogies for recursion, using games, visualizations, animations, multimedia environments, intelligent tutoring systems and visual programming. We cover the usage in schools of the Logo programming language and the associated theoretical didactics, including a brief overview of the constructivist and constructionist theories of learning; we also sketch the learners\u0027 mental models which have been identified so far, and non-classical remedial strategies, such as kinesthesis and syntonicity. We append an extensive and carefully collated bibliography, which we hope will facilitate new research. © 2014 Vilnius University.","weight\u003ccitations\u003e":"15.0","score\u003cpub._year\u003e":"2014.0","score\u003cnorm._citations\u003e":"2.4"},"color":"rgb(255,112,69)","size":10.0},{"label":"sulov v. (2016)","x":-191.77825927734375,"y":-54.79753494262695,"id":"10","attributes":{"cluster":"2","weight\u003clinks\u003e":"4.0","weight\u003cnorm._citations\u003e":"0.6716","score\u003ccitations\u003e":"5.0","Component ID":"1","Cluter-ID":"0","description":"\u003ctable\u003e\u003ctr\u003e\u003ctd\u003eAuthors:\u003c/td\u003e\u003ctd\u003esulov v.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eTitle:\u003c/td\u003e\u003ctd\u003eiteration vs recursion in introduction to programming classes: an empirical study\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eSource:\u003c/td\u003e\u003ctd\u003ecybernetics and information technologies, 16(4), 63-72\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eYear:\u003c/td\u003e\u003ctd\u003e2016\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e","abstract":"In this article we have presented the results of an empirical study which was carried out on 130 students in Introduction to programming classes. Their initial preference, success rate, comprehension and subsequent preference were studied when dealing with programming tasks which could be solved using either iteration or recursion.","weight\u003ccitations\u003e":"5.0","url":"https://doi.org/10.1515/cait-2016-0068","score\u003cpub._year\u003e":"2016.0","score\u003cnorm._citations\u003e":"0.6716"},"color":"rgb(140,185,0)","size":10.0},{"label":"bhuiyan s.h. (1990)","x":-251.26010131835938,"y":109.3352279663086,"id":"32","attributes":{"cluster":"5","weight\u003clinks\u003e":"1.0","weight\u003cnorm._citations\u003e":"0.5714","score\u003ccitations\u003e":"6.0","Component ID":"1","Cluter-ID":"3","description":"\u003ctable\u003e\u003ctr\u003e\u003ctd\u003eAuthors:\u003c/td\u003e\u003ctd\u003ebhuiyan s.h.; greer j.e.; mccalla g.i.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eTitle:\u003c/td\u003e\u003ctd\u003emental models of recursion and their use in the scent programming advisor\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eSource:\u003c/td\u003e\u003ctd\u003electure notes in computer science (including subseries lecture notes in artificial intelligence and lecture notes in bioinformatics), 444 lnai, 135-144\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eYear:\u003c/td\u003e\u003ctd\u003e1990\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e","abstract":"Mental modeling techniques are used to describe human understanding of the world, and to derive cognitive explanations of problem-solving behaviour. This paper identifies mental models of recursion through an investigation conducted among novice programmers. The necessity of using these mental models in diagnosis, pedagogy, and student modeling in an intelligent tutoring system is illustrated with the aid of a case study. The evolutionary and possible revolutionary development of mental models, coexistence of multiple models, and representation of these models are also discussed. © Springer-Verlag Berlin Heidelberg 1990.","weight\u003ccitations\u003e":"6.0","url":"https://doi.org/10.1007/bfb0018374","score\u003cpub._year\u003e":"1990.0","score\u003cnorm._citations\u003e":"0.5714"},"color":"rgb(0,199,255)","size":10.0},{"label":"segal j. (1994)","x":16.118227005004883,"y":224.50616455078125,"id":"27","attributes":{"cluster":"9","weight\u003clinks\u003e":"2.0","weight\u003cnorm._citations\u003e":"1.1739","score\u003ccitations\u003e":"18.0","Component ID":"1","Cluter-ID":"2","description":"\u003ctable\u003e\u003ctr\u003e\u003ctd\u003eAuthors:\u003c/td\u003e\u003ctd\u003esegal j.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eTitle:\u003c/td\u003e\u003ctd\u003eempirical studies of functional programming learners evaluating recursive functions\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eSource:\u003c/td\u003e\u003ctd\u003einstructional science, 22(5), 385-411\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eYear:\u003c/td\u003e\u003ctd\u003e1994\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e","abstract":"In this paper, we report some empirical studies of students evaluating recursive functions defined according to the rules of the functional programming language Miranda, and describe the misconceptions and processing strategies observed. We then discuss the implications of these observations as regards teaching content. © 1995 Kluwer Academic Publishers.","weight\u003ccitations\u003e":"18.0","url":"https://doi.org/10.1007/bf00891962","score\u003cpub._year\u003e":"1994.0","score\u003cnorm._citations\u003e":"1.1739"},"color":"rgb(35,150,111)","size":10.0},{"label":"stern l. (2002)","x":221.83389282226562,"y":-98.52774047851562,"id":"21","attributes":{"cluster":"3","weight\u003clinks\u003e":"1.0","weight\u003cnorm._citations\u003e":"0.5682","score\u003ccitations\u003e":"5.0","Component ID":"1","Cluter-ID":"1","description":"\u003ctable\u003e\u003ctr\u003e\u003ctd\u003eAuthors:\u003c/td\u003e\u003ctd\u003estern l.; naish l.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eTitle:\u003c/td\u003e\u003ctd\u003eanimating recursive algorithms\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eSource:\u003c/td\u003e\u003ctd\u003einteractive multimedia electronic journal of computer - enhanced learning, 4(2)\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eYear:\u003c/td\u003e\u003ctd\u003e2002\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e","abstract":"Designing visual representations for recursive algorithms has been addressed within a pedagogically-oriented framework for animating algorithms. We present a classification for choosing the kind of visual representation that is most helpful to students. The classification is based on the way the algorithm navigates through a data structure and manipulates data items within a data structure, and suggest strategies for visual representation that work within the categories of this classification. Further opportunities for tailoring representation derive from the shape of the data structure and particular forms of recursion, such as tail recursion. While there may be no single, general way to represent recursive algorithms, our classification is a useful guide to picking an appropriate strategy for use when animating recursive algorithms for teaching purposes.","weight\u003ccitations\u003e":"5.0","score\u003cpub._year\u003e":"2002.0","score\u003cnorm._citations\u003e":"0.5682"},"color":"rgb(217,125,216)","size":10.0},{"label":"goldwasser m.h. (2007)","x":4.750894069671631,"y":125.67444610595703,"id":"17","attributes":{"cluster":"4","weight\u003clinks\u003e":"1.0","weight\u003cnorm._citations\u003e":"0.7636","score\u003ccitations\u003e":"6.0","Component ID":"1","Cluter-ID":"4","description":"\u003ctable\u003e\u003ctr\u003e\u003ctd\u003eAuthors:\u003c/td\u003e\u003ctd\u003egoldwasser m.h.; letscher d.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eTitle:\u003c/td\u003e\u003ctd\u003eteaching strategies for reinforcing structural recursion with lists\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eSource:\u003c/td\u003e\u003ctd\u003eproceedings of the conference on object-oriented programming systems, languages, and applications, oopsla, 889-896\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eYear:\u003c/td\u003e\u003ctd\u003e2007\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e","abstract":"Recursion is an important concept in computer science and one that possesses beauty and simplicity, yet many educators describe challenges in teaching the topic. Kim Bruce champions the early use of structural recursion in an objectoriented introductory programming course as a more intuitive concept than traditional (functional) recursion. He uses many graphical examples for motivation (e.g., nested boxes, a ringed bullseye, fractals), providing concreteness to the recursive concept. Internally, most of those examples are disguised forms of a basic recursive list pattern. Recursive lists are important in and of themselves and a mainstay within the functional programming paradigm. However, further challenges exist in providing a tangible presentation for pure lists when disassociated from a graphical structure. We describe an active-learning exercise in which students play the roles of distinct objects that together comprise the structure of a single, recursive list. This activity establishes intuition that we later use when developing a complete implementation of a recursive list class. Our approach demonstrates a rich set of recursive patterns involving several distinct forms of a base case and varied use of parameters and return values.","weight\u003ccitations\u003e":"6.0","url":"https://doi.org/10.1145/1297846.1297940","score\u003cpub._year\u003e":"2007.0","score\u003cnorm._citations\u003e":"0.7636"},"color":"rgb(255,112,69)","size":10.0},{"label":"endres m. (2021)","x":-160.84347534179688,"y":-73.90882873535156,"id":"0","attributes":{"cluster":"2","weight\u003clinks\u003e":"3.0","weight\u003cnorm._citations\u003e":"1.0","score\u003ccitations\u003e":"0.0","Component ID":"1","Cluter-ID":"0","description":"\u003ctable\u003e\u003ctr\u003e\u003ctd\u003eAuthors:\u003c/td\u003e\u003ctd\u003eendres m.; weimer w.; kamil a.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eTitle:\u003c/td\u003e\u003ctd\u003ean analysis of iterative and recursive problem performance\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eSource:\u003c/td\u003e\u003ctd\u003esigcse 2021 - proceedings of the 52nd acm technical symposium on computer science education, 321-327\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eYear:\u003c/td\u003e\u003ctd\u003e2021\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e","abstract":"Iteration and recursion are fundamental programming constructs in introductory computer science. Understanding the relationship between contextual factors, such as problem formulation or student background, that relate to performance on iteration and recursion problems can help inform pedagogy. We present the results of a study of 162 undergraduate participants tasked with comprehending iterative, recursive, and tail-recursive versions of CS1 functions. First, we carry out a task-specific analysis, finding that students perform significantly better on the iterative framings of two problems with non-branching numerical computation and significantly better on the recursive framing of another that involves array classification (p \u003c \u003d 0.036). Second, we investigate differences in the most common student mistakes by program framing. We find that students were more likely to produce wrong answers with incorrect types or structures for recursive and tail-recursive program versions. Finally, we investigated correlations between programming performance and background factors including experience, gender, ethnicity, affluence, and spatial ability. We find that the factors relevant to explaining performance are similar for both iterative and recursive problems. While programming experience is the most significant factor, we find that spatial ability, gender, and ethnicity were more relevant for explaining performance than affluence. © 2021 ACM.","weight\u003ccitations\u003e":"0.0","score\u003cpub._year\u003e":"2021.0","score\u003cnorm._citations\u003e":"1.0"},"color":"rgb(140,185,0)","size":10.0},{"label":"al-fedaghi s. (2012)","x":239.4718780517578,"y":-83.0469741821289,"id":"15","attributes":{"cluster":"3","weight\u003clinks\u003e":"1.0","weight\u003cnorm._citations\u003e":"1.9231","score\u003ccitations\u003e":"5.0","Component ID":"1","Cluter-ID":"1","description":"\u003ctable\u003e\u003ctr\u003e\u003ctd\u003eAuthors:\u003c/td\u003e\u003ctd\u003eal-fedaghi s.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eTitle:\u003c/td\u003e\u003ctd\u003econceptual framework for recursion in computer programming\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eSource:\u003c/td\u003e\u003ctd\u003ejournal of theoretical and applied information technology, 46(2), 983-990\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eYear:\u003c/td\u003e\u003ctd\u003e2012\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e","abstract":"Recursion is an important concept and a fundamental problem-solving technique in computer science. Studies have reported that it is considered a very difficult concept for students to learn and teachers to teach, and students have many misconceptions about recursion. Tools proposed to overcome these difficulties include visualization and algorithm animation. Conceptual models form the basis of methods for teaching recursion and influence the instructional tactics used when teaching it. Conceptual models of recursion have been found to provide a necessary representation for understanding the mechanics of recursion. Several of these models have been proposed, including the Russian dolls model, process tracing model, mathematical induction model, and structure template model. These are not based on a systematic foundation that visualizes the process in terms of flows of the recursive algorithm from the stages of creating (copying) then processing (executing) it. This paper presents such a methodical conceptual picture that describes the recursive process in a precise, visual way that assists in teaching and learning. The new model is illustrated by several examples, including factorial and binary tree traversing. © 2005 - 2012 JATIT \u0026 LLS. All rights reserved.","weight\u003ccitations\u003e":"5.0","score\u003cpub._year\u003e":"2012.0","score\u003cnorm._citations\u003e":"1.9231"},"color":"rgb(217,125,216)","size":10.0},{"label":"rubio-sánchez m. (2010)","x":58.51052474975586,"y":-227.22525024414062,"id":"16","attributes":{"cluster":"1","weight\u003clinks\u003e":"1.0","weight\u003cnorm._citations\u003e":"1.1765","score\u003ccitations\u003e":"4.0","Component ID":"1","Cluter-ID":"0","description":"\u003ctable\u003e\u003ctr\u003e\u003ctd\u003eAuthors:\u003c/td\u003e\u003ctd\u003erubio-sánchez m.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eTitle:\u003c/td\u003e\u003ctd\u003etail recursive programming by applying generalization\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eSource:\u003c/td\u003e\u003ctd\u003eiticse\u002710 - proceedings of the 2010 acm sigcse annual conference on innovation and technology in computer science education, 98-102\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eYear:\u003c/td\u003e\u003ctd\u003e2010\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e","abstract":"The design of many tail recursive algorithms can involve thinking about the status of variables and parameters, and how these change with execution flow. In other words, tail recursion is closely related to iteration and imperative programming. However, it is possible to derive tail recursive functions by exclusively using concepts inherent in recursion, such as declarative programming, induction, or problem decomposition. This paper proposes a simple methodology for designing tail recursion functions by using a declarative approach and the concept of function generalization. We have carried out an evaluation of the technique with second and third-year computer science students. Results suggest that this new point of view improves students\u0027 ability to design tail recursive programs, helps them understand the distinction between the imperative and declarative paradigms, and may reinforce their programming skills in general. Furthermore, students found the methodology easy to learn and apply, simpler than more sophisticated formal methods, and described it as fast and methodic or mechanical, as it involves a sequence of well-defined steps. Copyright 2010 ACM.","weight\u003ccitations\u003e":"4.0","url":"https://doi.org/10.1145/1822090.1822119","score\u003cpub._year\u003e":"2010.0","score\u003cnorm._citations\u003e":"1.1765"},"color":"rgb(140,185,0)","size":10.0},{"label":"brodanac p. (2017)","x":229.5081024169922,"y":77.67902374267578,"id":"7","attributes":{"cluster":"8","weight\u003clinks\u003e":"1.0","weight\u003cnorm._citations\u003e":"0.0","score\u003ccitations\u003e":"0.0","Component ID":"1","Cluter-ID":"1","description":"\u003ctable\u003e\u003ctr\u003e\u003ctd\u003eAuthors:\u003c/td\u003e\u003ctd\u003ebrodanac p.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eTitle:\u003c/td\u003e\u003ctd\u003erecursions and how to teach them\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eSource:\u003c/td\u003e\u003ctd\u003e2017 40th international convention on information and communication technology, electronics and microelectronics, mipro 2017 - proceedings, 740-745\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eYear:\u003c/td\u003e\u003ctd\u003e2017\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e","abstract":"Learning programming is difficult. This refers to primary and secondary school students, but to university student beginners at programming too. These particular reasons stand as a challenge to teachers, as well. Most of the authors agree that recursion presents one of the most difficult concepts at programming, whereas some authors think it is the most difficult concept in programming. On the other hand, it is no longer only an important mathematical concept, but a programming technique, a way of algorithm thinking, and a tool to problem solving. There have been many attempts how to teach recursions. Hereinafter, one can find certain approaches for which authors claim to bring a better understanding of this important concept. © 2017 Croatian Society MIPRO.","weight\u003ccitations\u003e":"0.0","url":"https://doi.org/10.23919/mipro.2017.7973520","score\u003cpub._year\u003e":"2017.0","score\u003cnorm._citations\u003e":"0.0"},"color":"rgb(217,125,216)","size":10.0},{"label":"anyango j.t. (2018b)","x":-19.78230857849121,"y":-148.9066925048828,"id":"4","attributes":{"cluster":"1","weight\u003clinks\u003e":"2.0","weight\u003cnorm._citations\u003e":"0.0","score\u003ccitations\u003e":"0.0","Component ID":"1","Cluter-ID":"0","description":"\u003ctable\u003e\u003ctr\u003e\u003ctd\u003eAuthors:\u003c/td\u003e\u003ctd\u003eanyango j.t.; suleman h.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eTitle:\u003c/td\u003e\u003ctd\u003ea simulation game for effective teaching novices recursion\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eSource:\u003c/td\u003e\u003ctd\u003eacm international conference proceeding series, 327-329\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eYear:\u003c/td\u003e\u003ctd\u003e2018\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e","abstract":"For many beginners, learning to program has proved to be a challenging and difficult task. This problem has been compounded by the fact that most universities require students from non-computer science and mathematics disciplines to take compulsory introductory programming courses. Studies have reported high failure and dropout rates in introductory programming as well as computer science degrees, especially during and between the first and second years. At the global stage, these rates are estimated to fall between 30% and 50%. While the number of computer science students who successfully graduate in this discipline is on the decline, the industry demand for computing expertise is on the rise. Furthermore teaching computer programming has proved to be a complex task for many instructors. Previous studies have demonstrated that games have positive motivational and engagement impact on learners, though empirical evidence demonstrating the effectiveness of games on learning achievement remain scant. Some attempts have been made to use games to make it easier for people to learn to program. Studies that assessed the effectiveness of these games have shown that they can engage and motivate learners but they have not demonstrated that they make learners learn. In other education domains we also find that games cause people to engage more but do not necessarily accomplish the primary objective. Given this scenario, it would therefore appear that the secondary effects of the game, such as motivation and engagement, are not the purpose for having the game. The significance of the problem is that if the primary objective was being met then the game approach would be deemed successful and it would therefore provide evidence that games can be used in learning or programming in particular. Assuming this is true then it would appear that most past studies have ended up evaluating the secondary objective of the game for learning instead of the primary objective. Our study aims at evaluating the effect of Game Based Learning (GBL) on student learning outcome. A game that teaches programming will be designed and developed. An experimental study will be conducted to investigate the effects of the game on novices\u0027 learning achievement compared to outdated lecture methods used in some universities. Randomly sampled novices registered in an introductory programming course will be assigned to two groups. In the treatment group, participants will be taught using the game while in the control group learning will be conducted without the game. A pretest will be administered to both groups before the experiment, followed by a post-test after. Statistical analysis will be used to evaluate the effect of the teaching method on student learning between the two groups. We expect to find out what the impact of GBL is on programming, and whether it makes a difference or not in learning. Additionally, we expect to identify what part of the game based learning is more important or critical for learning. © 2018 Association for Computing Machinery.","weight\u003ccitations\u003e":"0.0","score\u003cpub._year\u003e":"2018.0","score\u003cnorm._citations\u003e":"0.0"},"color":"rgb(140,185,0)","size":10.0},{"label":"henderson p.b. (1989)","x":-254.03793334960938,"y":84.22112274169922,"id":"33","attributes":{"cluster":"5","weight\u003clinks\u003e":"1.0","weight\u003cnorm._citations\u003e":"2.3333","score\u003ccitations\u003e":"7.0","Component ID":"1","Cluter-ID":"3","description":"\u003ctable\u003e\u003ctr\u003e\u003ctd\u003eAuthors:\u003c/td\u003e\u003ctd\u003ehenderson p.b.; romero f.j.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eTitle:\u003c/td\u003e\u003ctd\u003eteaching recursion as a problem-solving tool using standard ml\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eSource:\u003c/td\u003e\u003ctd\u003eacm sigcse bulletin, 21(1), 27-31\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eYear:\u003c/td\u003e\u003ctd\u003e1989\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e","abstract":"Standard ML is a state of the art functional programming language, with features that make it excellent for teaching recursion and problem solving at the introductory level. Among the many pedagogically interesting characteristics of ML are its simple and uniform syntax, its type polymorphism and type inferencing system, and datatype declaration facilities. With little formal ML instruction, after several weeks first year students were able to use recursively defined data structures and to define fairly powerful recursive functions in ML. Standard ML is highly recommended as a tool for teaching recursive problem solving in the context of a course on the foundations of computer science. © 1989, ACM. All rights reserved.","weight\u003ccitations\u003e":"7.0","url":"https://doi.org/10.1145/65294.71190","score\u003cpub._year\u003e":"1989.0","score\u003cnorm._citations\u003e":"2.3333"},"color":"rgb(0,199,255)","size":10.0},{"label":"servin c. (2021)","x":-162.2827606201172,"y":-258.7152404785156,"id":"1","attributes":{"cluster":"6","weight\u003clinks\u003e":"2.0","weight\u003cnorm._citations\u003e":"1.0","score\u003ccitations\u003e":"0.0","Component ID":"1","Cluter-ID":"0","description":"\u003ctable\u003e\u003ctr\u003e\u003ctd\u003eAuthors:\u003c/td\u003e\u003ctd\u003eservin c.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eTitle:\u003c/td\u003e\u003ctd\u003ehow to teach recursion: a formula to transform an iterative-based to a recursive-based method\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eSource:\u003c/td\u003e\u003ctd\u003esigcse 2021 - proceedings of the 52nd acm technical symposium on computer science education, 1303\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eYear:\u003c/td\u003e\u003ctd\u003e2021\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e","abstract":"Recursion is one of the essential concepts in computer programming courses and one of the most challenging ideas to deliver in the fundamentals of computer programming courses effectively. Although several previous approaches aid students identify base and recursive cases when they write recursive-based methods, no algorithm has been proposed to help students understand the translation process between iterative to recursive. We proposed a teaching technique that allows students to translate components from loop-based programming to a recursive one. © 2021 Owner/Author.","weight\u003ccitations\u003e":"0.0","url":"https://doi.org/10.1145/3408877.3439670","score\u003cpub._year\u003e":"2021.0","score\u003cnorm._citations\u003e":"1.0"},"color":"rgb(140,185,0)","size":10.0},{"label":"hamouda s. (2019)","x":219.02598571777344,"y":2.0091145038604736,"id":"3","attributes":{"cluster":"8","weight\u003clinks\u003e":"2.0","weight\u003cnorm._citations\u003e":"3.5556","score\u003ccitations\u003e":"4.0","Component ID":"1","Cluter-ID":"1","description":"\u003ctable\u003e\u003ctr\u003e\u003ctd\u003eAuthors:\u003c/td\u003e\u003ctd\u003ehamouda s.; edwards s.h.; elmongui h.g.; ernst j.v.; shaffer c.a.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eTitle:\u003c/td\u003e\u003ctd\u003erecurtutor: an interactive tutorial for learning recursion\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eSource:\u003c/td\u003e\u003ctd\u003eacm transactions on computing education, 19(1)\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eYear:\u003c/td\u003e\u003ctd\u003e2019\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e","abstract":"Recursion is one of the most important and hardest topics in lower division computer science courses. As it is an advanced programming skill, the best way to learn it is through targeted practice exercises. But the best practice problems are time consuming to manually grade by an instructor. As a consequence, students historically have completed only a small number of recursion programming exercises as part of their coursework. We present a new way for teaching such programming skills. Students view examples and visualizations, then practice a wide variety of automatically assessed, small-scale programming exercises that address the sub-skills required to learn recursion. The basic recursion tutorial (RecurTutor) teaches material typically encountered in CS2 courses. Students who used RecurTutor had significantly better grades on recursion exam questions than did students who used typical instruction. Students who experienced RecurTutor spent significantly more time on solving recursive programming exercises than students who experienced typical instruction, and came out with a significantly higher confidence level. © 2018 Association for Computing Machinery.","weight\u003ccitations\u003e":"4.0","url":"https://doi.org/10.1145/3218328","score\u003cpub._year\u003e":"2019.0","score\u003cnorm._citations\u003e":"3.5556"},"color":"rgb(217,125,216)","size":10.0},{"label":"van someren m.w. (1990)","x":23.712575912475586,"y":320.6829528808594,"id":"31","attributes":{"cluster":"9","weight\u003clinks\u003e":"2.0","weight\u003cnorm._citations\u003e":"1.4286","score\u003ccitations\u003e":"15.0","Component ID":"1","Cluter-ID":"2","description":"\u003ctable\u003e\u003ctr\u003e\u003ctd\u003eAuthors:\u003c/td\u003e\u003ctd\u003evan someren m.w.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eTitle:\u003c/td\u003e\u003ctd\u003ewhat\u0027s wrong? understanding beginners\u0027 problems with prolog\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eSource:\u003c/td\u003e\u003ctd\u003einstructional science, 19(4-5), 257-282\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eYear:\u003c/td\u003e\u003ctd\u003e1990\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e","abstract":"This paper reviews psychological research on programming and applies it to the problems of learning and teaching Prolog. We present a psychological model that explains how a certain class of errors in programs comes about. The model fits quite well with the results of a small sample of students and problems. The problems that underlie these and other errors seem to be (a) the complexity of the Prolog primitives (unification and backtracking) and (b) the misfit between students\u0027 naive solutions to a problem and the constructs that are available in Prolog (e.g. iterative solutions do not map easily to recursive programs). This suggests that learning Prolog could be helped by (1) coherent and detailed instruction about how Prolog works, (2) emphasis on finding recursive solutions that do not rely on primitives such as assignment and (3) instruction in programming techniques that allow students to implement procedural solutions. © 1990 Kluwer Academic Publishers.","weight\u003ccitations\u003e":"15.0","url":"https://doi.org/10.1007/bf00116441","score\u003cpub._year\u003e":"1990.0","score\u003cnorm._citations\u003e":"1.4286"},"color":"rgb(35,150,111)","size":10.0}],"edges":[{"source":"0","target":"11","id":"1","attributes":{},"color":"rgb(140,185,0)","size":1.0},{"source":"1","target":"6","id":"3","attributes":{},"color":"rgb(140,185,0)","size":1.0},{"source":"12","target":"35","id":"28","attributes":{},"color":"rgb(0,199,255)","size":1.0},{"source":"14","target":"17","id":"31","attributes":{},"color":"rgb(255,112,69)","size":1.0},{"source":"9","target":"26","id":"21","attributes":{},"color":"rgb(140,185,0)","size":1.0},{"source":"9","target":"14","id":"20","attributes":{},"color":"rgb(197,148,34)","size":1.0},{"source":"1","target":"19","id":"4","attributes":{},"color":"rgb(140,185,0)","size":1.0},{"source":"23","target":"28","id":"43","attributes":{},"color":"rgb(217,125,216)","size":1.0},{"source":"14","target":"27","id":"34","attributes":{},"color":"rgb(145,131,90)","size":1.0},{"source":"10","target":"26","id":"22","attributes":{},"color":"rgb(140,185,0)","size":1.0},{"source":"12","target":"14","id":"26","attributes":{},"color":"rgb(127,155,162)","size":1.0},{"source":"18","target":"28","id":"40","attributes":{},"color":"rgb(217,125,216)","size":1.0},{"source":"0","target":"10","id":"0","attributes":{},"color":"rgb(140,185,0)","size":1.0},{"source":"3","target":"23","id":"7","attributes":{},"color":"rgb(217,125,216)","size":1.0},{"source":"8","target":"14","id":"18","attributes":{},"color":"rgb(236,118,142)","size":1.0},{"source":"14","target":"28","id":"35","attributes":{},"color":"rgb(236,118,142)","size":1.0},{"source":"4","target":"11","id":"9","attributes":{},"color":"rgb(140,185,0)","size":1.0},{"source":"14","target":"30","id":"36","attributes":{},"color":"rgb(255,112,69)","size":1.0},{"source":"24","target":"28","id":"44","attributes":{},"color":"rgb(217,125,216)","size":1.0},{"source":"34","target":"35","id":"50","attributes":{},"color":"rgb(0,199,255)","size":1.0},{"source":"21","target":"28","id":"42","attributes":{},"color":"rgb(217,125,216)","size":1.0},{"source":"4","target":"25","id":"10","attributes":{},"color":"rgb(140,185,0)","size":1.0},{"source":"20","target":"28","id":"41","attributes":{},"color":"rgb(217,125,216)","size":1.0},{"source":"29","target":"31","id":"47","attributes":{},"color":"rgb(35,150,111)","size":1.0},{"source":"11","target":"26","id":"25","attributes":{},"color":"rgb(140,185,0)","size":1.0},{"source":"5","target":"20","id":"13","attributes":{},"color":"rgb(217,125,216)","size":1.0},{"source":"16","target":"25","id":"39","attributes":{},"color":"rgb(140,185,0)","size":1.0},{"source":"3","target":"28","id":"8","attributes":{},"color":"rgb(217,125,216)","size":1.0},{"source":"5","target":"8","id":"11","attributes":{},"color":"rgb(217,125,216)","size":1.0},{"source":"2","target":"14","id":"6","attributes":{},"color":"rgb(255,112,69)","size":1.0},{"source":"33","target":"35","id":"49","attributes":{},"color":"rgb(0,199,255)","size":1.0},{"source":"27","target":"31","id":"46","attributes":{},"color":"rgb(35,150,111)","size":1.0},{"source":"32","target":"35","id":"48","attributes":{},"color":"rgb(0,199,255)","size":1.0},{"source":"8","target":"28","id":"19","attributes":{},"color":"rgb(217,125,216)","size":1.0},{"source":"13","target":"25","id":"29","attributes":{},"color":"rgb(178,155,108)","size":1.0},{"source":"0","target":"26","id":"2","attributes":{},"color":"rgb(140,185,0)","size":1.0},{"source":"5","target":"14","id":"12","attributes":{},"color":"rgb(236,118,142)","size":1.0},{"source":"6","target":"10","id":"14","attributes":{},"color":"rgb(140,185,0)","size":1.0},{"source":"15","target":"28","id":"38","attributes":{},"color":"rgb(217,125,216)","size":1.0},{"source":"7","target":"23","id":"17","attributes":{},"color":"rgb(217,125,216)","size":1.0},{"source":"2","target":"11","id":"5","attributes":{},"color":"rgb(197,148,34)","size":1.0},{"source":"10","target":"35","id":"23","attributes":{},"color":"rgb(70,192,127)","size":1.0},{"source":"12","target":"26","id":"27","attributes":{},"color":"rgb(70,192,127)","size":1.0},{"source":"14","target":"22","id":"32","attributes":{},"color":"rgb(255,112,69)","size":1.0},{"source":"6","target":"25","id":"16","attributes":{},"color":"rgb(140,185,0)","size":1.0},{"source":"13","target":"28","id":"30","attributes":{},"color":"rgb(217,125,216)","size":1.0},{"source":"6","target":"11","id":"15","attributes":{},"color":"rgb(140,185,0)","size":1.0},{"source":"25","target":"28","id":"45","attributes":{},"color":"rgb(178,155,108)","size":1.0},{"source":"14","target":"35","id":"37","attributes":{},"color":"rgb(127,155,162)","size":1.0},{"source":"14","target":"23","id":"33","attributes":{},"color":"rgb(236,118,142)","size":1.0},{"source":"11","target":"14","id":"24","attributes":{},"color":"rgb(197,148,34)","size":1.0}]}