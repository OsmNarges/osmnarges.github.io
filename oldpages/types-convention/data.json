{"nodes":[{"label":"Serrano (1995)","x":-130.8716278076172,"y":-33.3985481262207,"id":"18","attributes":{"venue":"SAS","comm":"1","keywords":"strict functional languages, optimizing compiler, functional language","year":"1995","author":"Manuel Serrano, Pierre Weis","citation_key":"Serrano1995Bigloo","dblp_id":"53e9997eb7602d97021bdc72","description":"\u003ctable\u003e\u003ctr\u003e\u003ctd\u003eAuthor:\u003c/td\u003e\u003ctd\u003eManuel Serrano\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eTitle:\u003c/td\u003e\u003ctd\u003eBigloo: A Portable and Optimizing Compiler for Strict Functional Languages\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eSource:\u003c/td\u003e\u003ctd\u003eSAS\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eYear:\u003c/td\u003e\u003ctd\u003e1995\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e","main":"0","abstract":"\u0026#34; . We present Bigloo, a highly portable and optimizing compiler.Bigloo is the first compiler for strict functional languages that canefficiently compile several languages: Bigloo is the first compiler for fullScheme and full ML, and for these two languages, Bigloo is one of themost efficient compiler now available (Bigloo is available by anonymousftp on ftp.inria.fr [192.93.2.54]).This high level of performance is achieved by numerous high-level optimizations.Some of those are classical... \u0026#34;","title":"Bigloo: A Portable and Optimizing Compiler for Strict Functional Languages","url":"http://dx.doi.org/10.1007/3-540-60360-3_50"},"color":"rgb(163,218,203)","size":12.0},{"label":"Jones (1992)","x":-151.58030700683594,"y":-86.15847778320312,"id":"4","attributes":{"venue":"Journal of Functional Programming","comm":"0","keywords":"higher order functions, abstract machine, functional language, operational semantics","year":"1992","author":"Simon L. Peyton Jones","citation_key":"Jones1992Implementing","dblp_id":"53e9b009b7602d9703a644a5","description":"\u003ctable\u003e\u003ctr\u003e\u003ctd\u003eAuthor:\u003c/td\u003e\u003ctd\u003eSimon L. Peyton Jones\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eTitle:\u003c/td\u003e\u003ctd\u003eImplementing lazy functional languages on stock hardware: the spineless tagless g-machine\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eSource:\u003c/td\u003e\u003ctd\u003eJournal of Functional Programming\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eYear:\u003c/td\u003e\u003ctd\u003e1992\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e","main":"0","abstract":"\u0026#34;\u0026#34;","title":"Implementing lazy functional languages on stock hardware: the spineless tagless g-machine","url":"http://dx.doi.org/10.1017/S0956796800000319"},"color":"rgb(187,228,219)","size":30.0},{"label":"Launchbury (1993)","x":-146.39266967773438,"y":-198.97157287597656,"id":"3","attributes":{"venue":"POPL","comm":"0","keywords":"higher level, accurate model, space behaviour, suitable framework, natural semantics, particular abstract machine, operational semantics, computational structure, lazy evaluation, abstract machine","year":"1993","author":"John Launchbury","citation_key":"Launchbury1993A","dblp_id":"53e999eeb7602d9702232d94","description":"\u003ctable\u003e\u003ctr\u003e\u003ctd\u003eAuthor:\u003c/td\u003e\u003ctd\u003eJohn Launchbury\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eTitle:\u003c/td\u003e\u003ctd\u003eA natural semantics for lazy evaluation\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eSource:\u003c/td\u003e\u003ctd\u003ePOPL\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eYear:\u003c/td\u003e\u003ctd\u003e1993\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e","main":"0","abstract":"\u0026#34;We define an operational semantics for lazy evaluation which provides an accurate model for sharing. The only computational structure we introduce is a set of bindings which corresponds closely to a heap. The semantics is set at a considerably higher level of abstraction than operational semantics for particular abstract machines, so is more suitable for a variety of proofs. Furthermore, because a heap is explicitly modelled, the semantics provides a suitable framework for studies about space behaviour of terms under lazy evaluation.\u0026#34;","title":"A natural semantics for lazy evaluation","url":"http://dx.doi.org/10.1145/158511.158618"},"color":"rgb(179,225,214)","size":18.0},{"label":"Jones (1996)","x":-297.03082275390625,"y":72.99681091308594,"id":"1","attributes":{"venue":"Proceedings of the first ACM SIGPLAN international conference on Functional programming","comm":"0","keywords":"optimizing compiler, functional language","year":"1996","author":"Simon Peyton Jones, Will Partain, Andr\u0026#233; Santos","citation_key":"Jones1996Let-floating","dblp_id":"53e9a73cb7602d9703075613","description":"\u003ctable\u003e\u003ctr\u003e\u003ctd\u003eAuthor:\u003c/td\u003e\u003ctd\u003eSimon Peyton Jones\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eTitle:\u003c/td\u003e\u003ctd\u003eLet-floating: moving bindings to give faster programs\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eSource:\u003c/td\u003e\u003ctd\u003eProceedings of the first ACM SIGPLAN international conference on Functional programming\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eYear:\u003c/td\u003e\u003ctd\u003e1996\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e","main":"0","abstract":"\u0026#34;Virtually every compiler performs transformations on the program it is compiling in an attempt to improve efficiency. Despite their importance, however, there have been few systematic attempts to categorise such transformations and measure their impact.In this paper we describe a particular group of transformations --- the \u0026#34;let-floating\u0026#34; transformations --- and give detailed measurements of their effect in an optimizing compiler for the non-strict functional language Haskell. Let-floating has not received much explicit attention in the past, but our measurements show that it is an important group of transformations (at least for lazy languages), offering a reduction of more than 30% in heap allocation and 15% in execution time.\u0026#34;","title":"Let-floating: moving bindings to give faster programs","url":"http://dx.doi.org/10.1145/232627.232630"},"color":"rgb(155,215,198)","size":18.0},{"label":"ILL (2009)","x":-149.49490356445312,"y":288.429931640625,"id":"13","attributes":{"venue":"JOURNAL OF FUNCTIONAL PROGRAMMING","comm":"0","keywords":"functional programming","year":"2009","author":"ANDY G ILL, GRAHAM H UTTON","citation_key":"ILL2009The","dblp_id":"53e99af2b7602d970237e4fc","description":"\u003ctable\u003e\u003ctr\u003e\u003ctd\u003eAuthor:\u003c/td\u003e\u003ctd\u003eANDY G ILL\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eTitle:\u003c/td\u003e\u003ctd\u003eThe worker/wrapper transformation\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eSource:\u003c/td\u003e\u003ctd\u003eJOURNAL OF FUNCTIONAL PROGRAMMING\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eYear:\u003c/td\u003e\u003ctd\u003e2009\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e","main":"0","abstract":"\u0026#34;The worker/wrapper transformation is a technique for changing the type of a computation, usually with the aim of improving its performance. It has been used by compiler writers for many years, but the technique is little known in the wider functional programming community, and has never been described precisely. In this article we explain, formalise and explore the generality of the worker/wrapper transformation. We also provide a systematic recipe for its use as an equational reasoning technique for improving the performance of programs, and illustrate the power of this recipe using a range of examples.\u0026#34;","title":"The worker/wrapper transformation","url":"http://dx.doi.org/10.1017/S0956796809007175"},"color":"rgb(61,160,116)","size":14.0},{"label":"Sulzmann (2007)","x":-48.52835464477539,"y":-136.57810974121094,"id":"17","attributes":{"venue":"TLDI","comm":"0","keywords":"system f, non-syntactic type equality, associated type, non-parametric type function, explicit witness, type equality, generalised algebraic data type, top-level equality axiom, type equality coercion, different source-language feature, system fc, data type","year":"2007","author":"Martin Sulzmann, Manuel M. T. Chakravarty, Simon Peyton Jones, Kevin Donnelly","citation_key":"Sulzmann2007System","dblp_id":"53e9b76eb7602d9704317728","description":"\u003ctable\u003e\u003ctr\u003e\u003ctd\u003eAuthor:\u003c/td\u003e\u003ctd\u003eMartin Sulzmann\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eTitle:\u003c/td\u003e\u003ctd\u003eSystem F with type equality coercions\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eSource:\u003c/td\u003e\u003ctd\u003eTLDI\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eYear:\u003c/td\u003e\u003ctd\u003e2007\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e","main":"0","abstract":"\u0026#34;We introduce System FC, which extends System F with support for non-syntactic type equality. There are two main extensions: (i) explicit witnesses for type equalities, and (ii) open, non-parametric type functions, given meaning by top-level equality axioms. Unlike System F, FC is expressive enough to serve as a target for several different source-language features, including Haskell\u0027s newtype, generalised algebraic data types, associated types, functional dependencies, and perhaps more besides.\u0026#34;","title":"System F with type equality coercions","url":"http://dx.doi.org/10.1145/1190315.1190324"},"color":"rgb(74,170,131)","size":14.0},{"label":"Dargaye (2009)","x":-204.84349060058594,"y":159.11474609375,"id":"12","attributes":{"venue":"Higher-Order and Symbolic Computation","comm":"0","keywords":"functional programming languages \u0026#183; compiler optimization \u0026#183; compiler verification \u0026#183; semantic preservation \u0026#183; mechanized verification, higher-order uncurrying optimizations, function uncurrying, generic framework, first-order uncurrying, efficient execution, important optimization, higher-order function, coq proof assistant, curried function, functional programming language, compiler optimization, functional programming languages, higher order functions, indexation, higher order, first order","year":"2009","author":"Zaynah Dargaye, Xavier Leroy","citation_key":"Dargaye2009A","dblp_id":"53e9a80db7602d9703152e7f","description":"\u003ctable\u003e\u003ctr\u003e\u003ctd\u003eAuthor:\u003c/td\u003e\u003ctd\u003eZaynah Dargaye\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eTitle:\u003c/td\u003e\u003ctd\u003eA verified framework for higher-order uncurrying optimizations\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eSource:\u003c/td\u003e\u003ctd\u003eHigher-Order and Symbolic Computation\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eYear:\u003c/td\u003e\u003ctd\u003e2009\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e","main":"0","abstract":"\u0026#34;Function uncurrying is an important optimization for the efficient execution of functional programming languages. This optimization replaces curried functions by uncurried, multiple-argument functions, while preserving the ability to evaluate partial applications. First-order uncurrying (where curried functions are optimized only in the static scopes of their definitions) is well understood and implemented by many compilers, but its extension to higher-order functions (where uncurrying can also be performed on parameters and results of higher-order functions) is challenging. This article develops a generic framework that expresses higher-order uncurrying optimizations as type-directed insertion of coercions, and prove its correctness. The proof uses step-indexed logical relations and was entirely mechanized using the Coq proof assistant.\u0026#34;","title":"A verified framework for higher-order uncurrying optimizations","url":"http://dx.doi.org/10.1007/s10990-010-9050-z"},"color":"rgb(61,160,116)","size":14.0},{"label":"Saiu (2012)","x":171.47134399414062,"y":-181.020751953125,"id":"22","attributes":{"venue":"CoRR","comm":"0","keywords":"","year":"2012","author":"Luca Saiu","citation_key":"Saiu2012GNU","dblp_id":"53e9bc27b7602d970489492d","description":"\u003ctable\u003e\u003ctr\u003e\u003ctd\u003eAuthor:\u003c/td\u003e\u003ctd\u003eLuca Saiu\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eTitle:\u003c/td\u003e\u003ctd\u003eGNU epsilon - an extensible programming language\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eSource:\u003c/td\u003e\u003ctd\u003eCoRR\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eYear:\u003c/td\u003e\u003ctd\u003e2012\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e","main":"0","abstract":"\u0026#34;  Reductionism is a viable strategy for designing and implementing practical programming languages, leading to solutions which are easier to extend, experiment with and formally analyze. We formally specify and implement an extensible programming language, based on a minimalistic first-order imperative core language plus strong abstraction mechanisms, reflection and self-modification features. The language can be extended to very high levels: by using Lisp-style macros and code-to-code transforms which automatically rewrite high-level expressions into core forms, we define closures and first-class continuations on top of the core. Non-self-modifying programs can be analyzed and formally reasoned upon, thanks to the language simple semantics. We formally develop a static analysis and prove a soundness property with respect to the dynamic semantics. We develop a parallel garbage collector suitable to multi-core machines to permit efficient execution of parallel programs. \u0026#34;","title":"GNU epsilon - an extensible programming language","url":"http://dx.doi.org/10.1145/1596638.1596650"},"color":"rgb(43,145,94)","size":10.0},{"label":"Ureche (2014)","x":184.15977478027344,"y":151.48374938964844,"id":"23","attributes":{"venue":"OOPSLA","comm":"0","keywords":"type systems, annotated types, data representation, object-oriented, local type inference, polymorphism, object representation, object oriented","year":"2014","author":"Vlad Ureche, Eugene Burmako, Martin Odersky","citation_key":"Ureche2014Late","dblp_id":"5550451045ce0a409eb534f3","description":"\u003ctable\u003e\u003ctr\u003e\u003ctd\u003eAuthor:\u003c/td\u003e\u003ctd\u003eVlad Ureche\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eTitle:\u003c/td\u003e\u003ctd\u003eLate data layout: unifying data representation transformations\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eSource:\u003c/td\u003e\u003ctd\u003eOOPSLA\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eYear:\u003c/td\u003e\u003ctd\u003e2014\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e","main":"0","abstract":"\u0026#34;Values need to be represented differently when interacting with certain language features. For example, an integer has to take an object-based representation when interacting with erased generics, although, for performance reasons, the stack-based value representation is better. To abstract over these implementation details, some programming languages choose to expose a unified high-level concept (the integer) and let the compiler choose its exact representation and insert coercions where necessary. This pattern appears in multiple language features such as value classes, specialization and multi-stage programming: they all expose a unified concept which they later refine into multiple representations. Yet, the underlying compiler implementations typically entangle the core mechanism with assumptions about the alternative representations and their interaction with other language features. In this paper we present the Late Data Layout mechanism, a simple but versatile type-driven generalization that subsumes and improves the state-of-the-art representation transformations. In doing so, we make two key observations: (1) annotated types conveniently capture the semantics of using multiple representations and (2) local type inference can be used to consistently and optimally introduce coercions. We validated our approach by implementing three language features as Scala compiler extensions: value classes, specialization (using the miniboxing representation) and a simplified multi-stage programming mechanism.\u0026#34;","title":"Late data layout: unifying data representation transformations","url":"http://dx.doi.org/10.1145/2660193.2660197"},"color":"rgb(30,134,80)","size":10.0},{"label":"Jones (1998)","x":-318.7018127441406,"y":-31.642501831054688,"id":"16","attributes":{"venue":"POPL","comm":"0","keywords":"intermediate language, side effect","year":"1998","author":"Simon L. Peyton Jones, Mark Shields, John Launchbury, Andrew P. Tolmach","citation_key":"Jones1998Bridging","dblp_id":"53e9a2b2b7602d9702bb7f20","description":"\u003ctable\u003e\u003ctr\u003e\u003ctd\u003eAuthor:\u003c/td\u003e\u003ctd\u003eSimon L. Peyton Jones\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eTitle:\u003c/td\u003e\u003ctd\u003eBridging the gulf: a common intermediate language for ML and Haskell\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eSource:\u003c/td\u003e\u003ctd\u003ePOPL\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eYear:\u003c/td\u003e\u003ctd\u003e1998\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e","main":"0","abstract":"\u0026#34; \u0026#34;","title":"Bridging the gulf: a common intermediate language for ML and Haskell","url":"http://dx.doi.org/10.1145/268946.268951"},"color":"rgb(138,208,187)","size":16.0},{"label":"Schrijvers (2010)","x":183.91455078125,"y":-123.8870849609375,"id":"19","attributes":{"venue":"SAS","comm":"0","keywords":"type-like inference system, dataflow analysis, strictness property, strictness analysis, abstract interpretation, additional optimisations, implicational strictness, best-property inference, data flow, order strictness effect, dataflow property, higher order, polymorphism","year":"2010","author":"Tom Schrijvers, Alan Mycroft","citation_key":"Schrijvers2010Strictness","dblp_id":"53e99b16b7602d97023a7914","description":"\u003ctable\u003e\u003ctr\u003e\u003ctd\u003eAuthor:\u003c/td\u003e\u003ctd\u003eTom Schrijvers\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eTitle:\u003c/td\u003e\u003ctd\u003eStrictness meets data flow\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eSource:\u003c/td\u003e\u003ctd\u003eSAS\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eYear:\u003c/td\u003e\u003ctd\u003e2010\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e","main":"0","abstract":"\u0026#34;Properties of programs can be formulated using various techniques: dataflow analysis, abstract interpretation and type-like inference systems. This paper reconstructs strictness analysis (establishing when function parameters are evaluated in a lazy language) as a dataflow analysis by expressing the dataflow properties as an effect system. Strictness properties so expressed give a clearer operational understanding and enable a range of additional optimisations including implicational strictness. At first order strictness effects have the expected principality properties (best-property inference) and can be computed simply.\u0026#34;","title":"Strictness meets data flow","url":"http://dx.doi.org/10.1007/978-3-642-15769-1_27"},"color":"rgb(55,155,109)","size":10.0},{"label":"Hannan (1998)","x":-74.60444641113281,"y":229.2339630126953,"id":"0","attributes":{"venue":"Symposium on Principles of Programming Languages","comm":"0","keywords":"type systems, higher-order uncurrying, program transformations, semantics-based program analysis, operational semantics, functional language, type system, higher order, program analysis, formal specification, polymorphism, source term, higher order functions","year":"1998","author":"John Hannan, Patrick Hicks","citation_key":"Hannan1998Higher-order","dblp_id":"53e997fcb7602d97020066ba","description":"\u003ctable\u003e\u003ctr\u003e\u003ctd\u003eAuthor:\u003c/td\u003e\u003ctd\u003eJohn Hannan\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eTitle:\u003c/td\u003e\u003ctd\u003eHigher-order unCurrying\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eSource:\u003c/td\u003e\u003ctd\u003eSymposium on Principles of Programming Languages\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eYear:\u003c/td\u003e\u003ctd\u003e1998\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e","main":"0","abstract":"\u0026#34;We present a formal specification of unCurrying for a higher-order, functional language with ML-style let-polymorphism. This specification supports the general unCurrying of functions, even for functions that are passed as arguments or returned as values. The specification also supports partial unCurrying of any consecutive parameters of a function,rather than only unCurrying all of a function\u0027s parameters. We present the specification as a deductive system that axiomatizes a judgment relating a source term with an unCurried form of the term. We prove that this system relates only typable terms and that it is correct with respect to an operational semantics. We define a practical algorithm, based on algorithmW, that implements unCurrying and prove this algorithm sound and complete with respect to the deductive system. This algorithm generates maximally unCurried forms of source terms. These results provide a declarative framework for reasoning about unCurrying and support a richer form of unCurrying than is currently found in compilers for functional languages.\u0026#34;","title":"Higher-order unCurrying","url":"http://dx.doi.org/10.1145/268946.268947"},"color":"rgb(138,208,187)","size":16.0},{"label":"Hannan (1998)","x":-236.1460723876953,"y":234.6405792236328,"id":"2","attributes":{"venue":"ICFP \u002798 Proceedings of the third ACM SIGPLAN international conference on Functional programming","comm":"0","keywords":"formal specification, functional language, higher order functions, program optimization, higher order","year":"1998","author":"John Hannan, Patrick Hicks","citation_key":"Hannan1998Higher-order","dblp_id":"53e99ab8b7602d9702331505","description":"\u003ctable\u003e\u003ctr\u003e\u003ctd\u003eAuthor:\u003c/td\u003e\u003ctd\u003eJohn Hannan\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eTitle:\u003c/td\u003e\u003ctd\u003eHigher-order arity raising\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eSource:\u003c/td\u003e\u003ctd\u003eICFP \u002798 Proceedings of the third ACM SIGPLAN international conference on Functional programming\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eYear:\u003c/td\u003e\u003ctd\u003e1998\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e","main":"0","abstract":"\u0026#34;Arity raising, also known as variable splitting or flattening, is the program optimization which transforms a function of one argument into a function of several arguments by decomposing the structure of the original one argument into individual components in that structure. This optimization eliminates the need for the structuring of the components and also allows more arguments to be passed in registers during a function call. We present a formal specification of arity raising for a higher-order functional language. This specification supports the general arity raising of functions, even for functions which are passed as arguments or returned as values. We define a practical algorithm, based on algorithm W, which implements arity raising, and we prove this algorithm sound with respect to the deductive system. These results provide a declarative framework for reasoning about arity raising and support a richer form of the transformation than is currently found in compilers for functional languages.\u0026#34;","title":"Higher-order arity raising","url":"http://dx.doi.org/10.1145/289423.289426"},"color":"rgb(138,208,187)","size":20.0},{"label":"Brus (1987)","x":-133.4041748046875,"y":1.1768875122070312,"id":"9","attributes":{"venue":"FPCA","comm":"0","keywords":"functional graph writing","year":"1987","author":"T. H. Brus, Marko C. J. D. van Eekelen, M. O. van Leer, Marinus J. Plasmeijer","citation_key":"Brus1987CLEAN","dblp_id":"53e9b5c8b7602d970411616a","description":"\u003ctable\u003e\u003ctr\u003e\u003ctd\u003eAuthor:\u003c/td\u003e\u003ctd\u003eT. H. Brus\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eTitle:\u003c/td\u003e\u003ctd\u003eCLEAN: A language for functional graph writing\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eSource:\u003c/td\u003e\u003ctd\u003eFPCA\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eYear:\u003c/td\u003e\u003ctd\u003e1987\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e","main":"0","abstract":"\u0026#34;Clean is an experimental language for specifying functional computations in terms of graph rewriting. It is based on an extension of Term Rewriting Systems (TRS) in which the terms are replaced by graphs. Such a Graph Rewriting System (GRS) consists of a, possibly cyclic, directed graph, called the data graph and graph rewrite rules which specify how this data graph may be rewritten. Clean is designed to provide a firm base for functional programming. In particular, Clean is suitable as an intermediate language between functional languages and (parallel) target machine architectures. A sequential implementation of Clean on a conventional machine is described and its performance is compared with other systems. The results show that Clean can be efficiently implemented.\u0026#34;","title":"CLEAN: A language for functional graph writing","url":"http://dx.doi.org/10.1007/3-540-18317-5_20"},"color":"rgb(228,244,245)","size":14.0},{"label":"Downen (2019)","x":171.29527282714844,"y":214.02012634277344,"id":"24","attributes":{"venue":"Haskell@ICFP","comm":"0","keywords":"arity,  extensionality,  type systems","year":"2019","author":"Paul Downen, Zachary Sullivan, Zena M. Ariola, Simon Peyton Jones","citation_key":"Downen2019Making","dblp_id":"5d416fe13a55ac570536d34e","description":"\u003ctable\u003e\u003ctr\u003e\u003ctd\u003eAuthor:\u003c/td\u003e\u003ctd\u003ePaul Downen\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eTitle:\u003c/td\u003e\u003ctd\u003eMaking a faster Curry with extensional types.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eSource:\u003c/td\u003e\u003ctd\u003eHaskell@ICFP\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eYear:\u003c/td\u003e\u003ctd\u003e2019\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e","main":"0","abstract":"\u0026#34;Curried functions apparently take one argument at a time, which is slow. So optimizing compilers for higher-order languages invariably have some mechanism for working around currying by passing several arguments at once, as many as the function can handle, which is known as its arity. But such mechanisms are often ad-hoc, and do not work at all in higher-order functions. We show how extensional, call-by-name functions have the correct behavior for directly expressing the arity of curried functions. And these extensional functions can stand side-by-side with functions native to practical programming languages, which do not use call-by-name evaluation. Integrating call-by-name with other evaluation strategies in the same intermediate language expresses the arity of a function in its type and gives a principled and compositional account of multi-argument curried functions. An unexpected, but significant, bonus is that our approach is equally suitable for a call-by-value language and a call-by-need language, and it can be readily integrated into an existing compilation framework.\u0026#10;\u0026#10;\u0026#34;","title":"Making a faster Curry with extensional types.","url":"https://doi.org/10.1145/3331545.3342594"},"color":"rgb(0,109,44)","size":10.0},{"label":"Jones (1998)","x":-258.80426025390625,"y":-70.42391204833984,"id":"8","attributes":{"venue":"Sci. Comput. Program.","comm":"0","keywords":"transformation, functional languages, second-order lambda calculus, linear type system, transformation-based optimiser, let-floating, compilers, strictness analysis, optimisation, type system, lambda calculus, functional language, second order","year":"1998","author":"Simon L. Peyton Jones, Andr\u0026#233; L. M. Santos","citation_key":"Jones1998A","dblp_id":"53e9ba70b7602d97046912c0","description":"\u003ctable\u003e\u003ctr\u003e\u003ctd\u003eAuthor:\u003c/td\u003e\u003ctd\u003eSimon L. Peyton Jones\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eTitle:\u003c/td\u003e\u003ctd\u003eA transformation-based optimiser for Haskell\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eSource:\u003c/td\u003e\u003ctd\u003eSci. Comput. Program.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eYear:\u003c/td\u003e\u003ctd\u003e1998\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e","main":"0","abstract":"\u0026#34;Many compilers do some of their work by means of correctness-preserving, and hopefully performance-improving, program transformations. The Glasgow Haskell Compiler (GHC) takes this idea of \u0026#8220;compilation by transformation\u0026#8221; as its war-cry, trying to express as much as possible of the compilation process in the form of program transformations. This paper reports on our practical experience of the transformational approach to compilation, in the context of a substantial compiler.\u0026#34;","title":"A transformation-based optimiser for Haskell","url":"http://dx.doi.org/10.1016/S0167-6423(97)00029-4"},"color":"rgb(138,208,187)","size":14.0},{"label":"Bergstrom (2009)","x":143.61158752441406,"y":16.112268447875977,"id":"5","attributes":{"venue":"IFL","comm":"0","keywords":"polymorphic language, complex structure, raw value, memory usage, source level, newfound import, extra operation, execution path, argument tuples, novel strategy, polymorphism, control flow","year":"2009","author":"Lars Bergstrom, John Reppy","citation_key":"Bergstrom2009Arity","dblp_id":"53e99a52b7602d97022b93bc","description":"\u003ctable\u003e\u003ctr\u003e\u003ctd\u003eAuthor:\u003c/td\u003e\u003ctd\u003eLars Bergstrom\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eTitle:\u003c/td\u003e\u003ctd\u003eArity raising in manticore\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eSource:\u003c/td\u003e\u003ctd\u003eIFL\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eYear:\u003c/td\u003e\u003ctd\u003e2009\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e","main":"0","abstract":"\u0026#34;Compilers for polymorphic languages are required to treat values in programs in an abstract and generic way at the source level. The challenges of optimizing the boxing of raw values, flattening of argument tuples, and raising the arity of functions that handle complex structures to reduce memory usage are old ones, but take on newfound import with processors that have twice as many registers. We present a novel strategy that uses both control-flow and type information to provide an arity raising implementation addressing these problems. This strategy is conservative -- no matter the execution path, the transformed program will not perform extra operations.\u0026#34;","title":"Arity raising in manticore","url":"http://dx.doi.org/10.1007/978-3-642-16478-1_6"},"color":"rgb(61,160,116)","size":12.0},{"label":"Benton (1998)","x":-276.0982666015625,"y":-139.5770263671875,"id":"14","attributes":{"venue":"ICFP \u002798 Proceedings of the third ACM SIGPLAN international conference on Functional programming","comm":"0","keywords":"intermediate language, data representation, type system, polymorphism","year":"1998","author":"Nick Benton, Andrew Kennedy, George Russell","citation_key":"Benton1998Compiling","dblp_id":"53e9a114b7602d9702a065b1","description":"\u003ctable\u003e\u003ctr\u003e\u003ctd\u003eAuthor:\u003c/td\u003e\u003ctd\u003eNick Benton\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eTitle:\u003c/td\u003e\u003ctd\u003eCompiling standard ML to Java bytecodes\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eSource:\u003c/td\u003e\u003ctd\u003eICFP \u002798 Proceedings of the third ACM SIGPLAN international conference on Functional programming\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eYear:\u003c/td\u003e\u003ctd\u003e1998\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e","main":"0","abstract":"\u0026#34;MLJ compiles SML\u002797 into verifier-compliant Java byte-codes. Its features include type-checked interlanguage working extensions which allow ML and Java code to call each other, automatic recompilation management, compact compiled code and runtime performance which, using a \u0027just in time\u0027 compiling Java virtual machine, usually exceeds that of existing specialised bytecode interpreters for ML. Notable features of the compiler itself include whole-program optimisation based on rewriting, compilation of polymorphism by specialisation, a novel monadic intermediate language which expresses effect information in the type system and some interesting data representation choices.\u0026#34;","title":"Compiling standard ML to Java bytecodes","url":"http://dx.doi.org/10.1145/289423.289435"},"color":"rgb(138,208,187)","size":12.0},{"label":"Bolingbroke (2009)","x":-1.060556411743164,"y":1.2602648735046387,"id":"6","attributes":{"venue":"Haskell","comm":"0","keywords":"higher-order functional language, missing distinction, intermediate language, multiple result, strictness, multiple argument, uncurrying, calling conventions, extensive use, arity, strict core, lost opportunity, unboxing, new intermediate language, optimisation opportunity, type system, higher order functions","year":"2009","author":"Maximilian C. Bolingbroke, Simon L. Peyton Jones","citation_key":"Bolingbroke2009Types","dblp_id":"53e99adcb7602d970235fac9","description":"\u003ctable\u003e\u003ctr\u003e\u003ctd\u003eAuthor:\u003c/td\u003e\u003ctd\u003eMaximilian C. Bolingbroke\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eTitle:\u003c/td\u003e\u003ctd\u003eTypes are calling conventions\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eSource:\u003c/td\u003e\u003ctd\u003eHaskell\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eYear:\u003c/td\u003e\u003ctd\u003e2009\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e","main":"1","abstract":"\u0026#34;It is common for compilers to derive the calling convention of a function from its type. Doing so is simple and modular but misses many optimisation opportunities, particularly in lazy, higher-order functional languages with extensive use of currying. We restore the lost opportunities by defining Strict Core, a new intermediate lan- guage whose type system makes the missing distinctions: laziness is explicit, and functions take multiple arguments and return multi- ple results.\u0026#34;","title":"Types are calling conventions","url":"http://dx.doi.org/10.1145/1596638.1596640"},"color":"rgb(61,160,116)","size":24.0},{"label":"Liu (2013)","x":209.0875701904297,"y":-31.312034606933594,"id":"20","attributes":{"venue":"Haskell","comm":"0","keywords":"aggressive optimization, intel labs haskell research, virtual machine, llvm backend, haskell research compiler, generic functional language compilation, external core language, reusing ghc, haskell programming language, intel lab, ghc intermediate representation, glasgow haskell compiler, compiler optimization","year":"2013","author":"Hai Liu, Neal Glew, Leaf Petersen, Todd A. Anderson","citation_key":"Liu2013The","dblp_id":"53e9b3fdb7602d9703eecb4d","description":"\u003ctable\u003e\u003ctr\u003e\u003ctd\u003eAuthor:\u003c/td\u003e\u003ctd\u003eHai Liu\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eTitle:\u003c/td\u003e\u003ctd\u003eThe Intel labs Haskell research compiler\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eSource:\u003c/td\u003e\u003ctd\u003eHaskell\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eYear:\u003c/td\u003e\u003ctd\u003e2013\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e","main":"0","abstract":"\u0026#34;The Glasgow Haskell Compiler (GHC) is a well supported optimizing compiler for the Haskell programming language, along with its own extensions to the language and libraries. Haskell\u0027s lazy semantics imposes a runtime model which is in general difficult to implement efficiently. GHC achieves good performance across a wide variety of programs via aggressive optimization taking advantage of the lack of side effects, and by targeting a carefully tuned virtual machine. The Intel Labs Haskell Research Compiler uses GHC as a frontend, but provides a new whole-program optimizing backend by compiling the GHC intermediate representation to a relatively generic functional language compilation platform. We found that GHC\u0027s external Core language was relatively easy to use, but reusing GHC\u0027s libraries and achieving full compatibility were harder. For certain classes of programs, our platform provides substantial performance benefits over GHC alone, performing 2x faster than GHC with the LLVM backend on selected modern performance-oriented benchmarks; for other classes of programs, the benefits of GHC\u0027s tuned virtual machine continue to outweigh the benefits of more aggressive whole program optimization. Overall we achieve parity with GHC with the LLVM backend. In this paper, we describe our Haskell compiler stack, its implementation and optimization approach, and present benchmark results comparing it to GHC.\u0026#34;","title":"The Intel labs Haskell research compiler","url":"http://dx.doi.org/10.1145/2503778.2503779"},"color":"rgb(37,139,87)","size":10.0},{"label":"Rudiak-Gould (2006)","x":-229.0985870361328,"y":-201.38357543945312,"id":"11","attributes":{"venue":"ESOP","comm":"0","keywords":"ml value, compilation function, haskell value, ml type, function arrow, calculus il, double negation, haskell family, haskell deepseq, maps value, intermediate language, type system, functional programming","year":"2006","author":"Ben Rudiak-Gould, Alan Mycroft, Simon Peyton Jones","citation_key":"Rudiak-Gould2006Haskell","dblp_id":"53e9aa24b7602d9703391bbd","description":"\u003ctable\u003e\u003ctr\u003e\u003ctd\u003eAuthor:\u003c/td\u003e\u003ctd\u003eBen Rudiak-Gould\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eTitle:\u003c/td\u003e\u003ctd\u003eHaskell is not not ML\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eSource:\u003c/td\u003e\u003ctd\u003eESOP\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eYear:\u003c/td\u003e\u003ctd\u003e2006\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e","main":"0","abstract":"\u0026#34;We present a typed calculus IL (\u0026#8220;intermediate language\u0026#8221;) which supports the embedding of ML-like (strict, eager) and Haskell-like (non-strict, lazy) languages, without favoring either. IL\u0027s type system includes negation (continuations), but not implication (function arrow). Within IL we find that lifted sums and products can be represented as the double negation of their unlifted counterparts. We exhibit a compilation function from IL to AM\u0026#8212;an abstract von Neumann machine\u0026#8212;which maps values of ordinary and doubly negated types to heap structures resembling those found in practical implementations of languages in the ML and Haskell families. Finally, we show that a small variation in the design of AM allows us to treat any ML value as a Haskell value at runtime without cost, and project a Haskell value onto an ML type with only the cost of a Haskell deepSeq. This suggests that IL and AM may be useful as a compilation and execution model for a new language which combines the best features of strict and non-strict functional programming.\u0026#34;","title":"Haskell is not not ML","url":"http://dx.doi.org/10.1007/11693024_4"},"color":"rgb(80,175,138)","size":12.0},{"label":"Baker-Finch (2000)","x":-225.55361938476562,"y":106.17376708984375,"id":"15","attributes":{"venue":"J. Funct. Program.","comm":"0","keywords":"constructed product result, lazy functional language, constructed product result analysis, separate compilation, multiple result, function definition, substantial benchmark set, design issue, multiple argument, performance ratio, good deal, functional language, benchmarking, functions, optimization, computational complexity, profitability, logic design, computer programming languages","year":"2000","author":"Clem Baker-Finch, Kevin Glynn, Simon Peyton Jones","citation_key":"Baker-Finch2000Constructed","dblp_id":"53e9a217b7602d9702b1cdd6","description":"\u003ctable\u003e\u003ctr\u003e\u003ctd\u003eAuthor:\u003c/td\u003e\u003ctd\u003eClem Baker-Finch\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eTitle:\u003c/td\u003e\u003ctd\u003eConstructed product result analysis for Haskell\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eSource:\u003c/td\u003e\u003ctd\u003eJ. Funct. Program.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eYear:\u003c/td\u003e\u003ctd\u003e2000\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e","main":"0","abstract":"\u0026#34;Compilers for ML and Haskell typically go to a good deal of trouble to arrange that multiple arguments can be passed efficiently to a procedure. For some reason, less effort seems to be invested in ensuring that multiple results can also be returned efficiently. In the context of the lazy functional language Haskell, we describe an analysis, Constructed Product Result (CPR) analysis, that determines when a function can profitably return multiple results in registers. The analysis is based only on a function\u0027s definition, and not on its uses (so separate compilation is easily supported) and the results of the analysis can be expressed by a transformation of the function definition alone. We discuss a variety of design issues that were addressed in our implementation, and give measurements of the effectiveness of our approach across a substantial benchmark set. Overall, the price\u0026#38;sol;performance ratio is good: the benefits are modest in general (though occasionally dramatic), but the costs in both complexity and compile time, are low.\u0026#34;","title":"Constructed product result analysis for Haskell","url":"http://dx.doi.org/10.1017/S0956796803004751"},"color":"rgb(122,202,177)","size":12.0},{"label":"Jones (1991)","x":-134.57992553710938,"y":74.73672485351562,"id":"7","attributes":{"venue":"FPCA","comm":"0","keywords":"unboxed values, non-strict functional language, unboxed value, first class citizens, class citizen, functional programming, code generation, functional language","year":"1991","author":"Simon L. Peyton Jones, John Launchbury","citation_key":"Jones1991Unboxed","dblp_id":"53e9a1dbb7602d9702ad7685","description":"\u003ctable\u003e\u003ctr\u003e\u003ctd\u003eAuthor:\u003c/td\u003e\u003ctd\u003eSimon L. Peyton Jones\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eTitle:\u003c/td\u003e\u003ctd\u003eUnboxed values as first class citizens in a non-strict functional language\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eSource:\u003c/td\u003e\u003ctd\u003eFPCA\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eYear:\u003c/td\u003e\u003ctd\u003e1991\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e","main":"0","abstract":"\u0026#34; The code compiled from a non-strict functional program usually manipulates heapallocated boxed numbers. Compilers for such languages often go to considerable trouble to optimise operations on boxed numbers into simpler operations on their unboxed forms. These optimisations are usually handled in an ad hoc manner in the code generator, because earlier phases of the compiler have no way to talk about unboxed values. We present a new approach, which makes unboxed values into (nearly) first-class... \u0026#34;","title":"Unboxed values as first class citizens in a non-strict functional language","url":"http://dx.doi.org/10.1007/3540543961_30"},"color":"rgb(196,231,224)","size":26.0},{"label":"Dijkstra (2009)","x":183.8196258544922,"y":95.99465942382812,"id":"21","attributes":{"venue":"Haskell","comm":"0","keywords":"bytecode interpreter backend, aspect-oriented internal organization, multiple backends, experimental extension, new haskell compiler, utrecht haskell compiler, whole-program analysis backend, attribute grammar, language variant, explicit intermediate language, intermediate language, aspect oriented, program analysis","year":"2009","author":"Atze Dijkstra, Jeroen Fokker, S. Doaitse Swierstra","citation_key":"Dijkstra2009The","dblp_id":"53e9b76eb7602d9704313676","description":"\u003ctable\u003e\u003ctr\u003e\u003ctd\u003eAuthor:\u003c/td\u003e\u003ctd\u003eAtze Dijkstra\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eTitle:\u003c/td\u003e\u003ctd\u003eThe architecture of the Utrecht Haskell compiler\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eSource:\u003c/td\u003e\u003ctd\u003eHaskell\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eYear:\u003c/td\u003e\u003ctd\u003e2009\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e","main":"0","abstract":"\u0026#34;In this paper we describe the architecture of the Utrecht Haskell Compiler (UHC). UHC is a new Haskell compiler, that supports most (but not all) Haskell 98 features, plus some experimental extensions. It targets multiple backends, including a bytecode interpreter backend and a whole-program analysis backend, both via C. The implementation is rigorously organized as stepwise transformations through some explicit intermediate languages. The tree walks of all transformations are expressed as an algebra, with the aid of an Attribute Grammar based preprocessor. The compiler is just one materialization of a framework that supports experimentation with language variants, thanks to an aspect-oriented internal organization.\u0026#34;","title":"The architecture of the Utrecht Haskell compiler","url":"http://dx.doi.org/10.1145/1596638.1596650"},"color":"rgb(61,160,116)","size":12.0},{"label":"Girard (1986)","x":-264.43798828125,"y":166.732421875,"id":"10","attributes":{"venue":"Theor. Comput. Sci.","comm":"0","keywords":"fifteen year, variable type, system F","year":"1986","author":"Jean-Yves Girard","citation_key":"Girard1986The","dblp_id":"53e9ba32b7602d970464208c","description":"\u003ctable\u003e\u003ctr\u003e\u003ctd\u003eAuthor:\u003c/td\u003e\u003ctd\u003eJean-Yves Girard\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eTitle:\u003c/td\u003e\u003ctd\u003eThe system F of variable types, fifteen years later\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eSource:\u003c/td\u003e\u003ctd\u003eTheor. Comput. Sci.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eYear:\u003c/td\u003e\u003ctd\u003e1986\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e","main":"0","abstract":"\u0026#34;The semantic study of system F stumbles on the problem of variable types for which there was no convincing interpretation; we develop here a semantics based on the category-theoretic idea of direct limit , so that the behaviour of a variable type on any domain is determined by its behaviour on finite ones, thus getting rid of the circularity of variable types. To do so, one has first to simplify somehow the extant semantic ideas, replacing Scott domains by the simpler and more finitary qualitative domains . The interpretation obtained is extremely compact, as shown on simple examples. The paper also contains the definitions of a very small \u0026#8216;universal model\u0026#8217; of lambda-calculus, and investigates the concept totality.\u0026#34;","title":"The system F of variable types, fifteen years later","url":"http://dx.doi.org/10.1016/0304-3975(86)90044-7"},"color":"rgb(237,248,251)","size":16.0}],"edges":[{"source":"0","target":"1","id":"0","attributes":{},"color":"rgb(146,211,192)","size":1.0},{"source":"6","target":"7","id":"22","attributes":{},"color":"rgb(128,195,170)","size":1.0},{"source":"14","target":"4","id":"37","attributes":{},"color":"rgb(162,218,203)","size":1.0},{"source":"5","target":"2","id":"8","attributes":{},"color":"rgb(99,184,151)","size":1.0},{"source":"8","target":"4","id":"30","attributes":{},"color":"rgb(162,218,203)","size":1.0},{"source":"19","target":"6","id":"46","attributes":{},"color":"rgb(58,157,112)","size":1.0},{"source":"6","target":"2","id":"21","attributes":{},"color":"rgb(99,184,151)","size":1.0},{"source":"8","target":"1","id":"28","attributes":{},"color":"rgb(146,211,192)","size":1.0},{"source":"24","target":"6","id":"58","attributes":{},"color":"rgb(30,134,80)","size":1.0},{"source":"0","target":"2","id":"1","attributes":{},"color":"rgb(138,208,187)","size":1.0},{"source":"6","target":"0","id":"11","attributes":{},"color":"rgb(99,184,151)","size":1.0},{"source":"15","target":"7","id":"40","attributes":{},"color":"rgb(159,216,200)","size":1.0},{"source":"24","target":"12","id":"59","attributes":{},"color":"rgb(30,134,80)","size":1.0},{"source":"21","target":"6","id":"53","attributes":{},"color":"rgb(61,160,116)","size":1.0},{"source":"6","target":"10","id":"15","attributes":{},"color":"rgb(149,204,183)","size":1.0},{"source":"6","target":"3","id":"12","attributes":{},"color":"rgb(120,192,165)","size":1.0},{"source":"20","target":"5","id":"50","attributes":{},"color":"rgb(49,149,101)","size":1.0},{"source":"6","target":"4","id":"24","attributes":{},"color":"rgb(124,194,167)","size":1.0},{"source":"7","target":"9","id":"27","attributes":{},"color":"rgb(212,237,234)","size":1.0},{"source":"6","target":"12","id":"17","attributes":{},"color":"rgb(61,160,116)","size":1.0},{"source":"6","target":"14","id":"19","attributes":{},"color":"rgb(99,184,151)","size":1.0},{"source":"5","target":"7","id":"9","attributes":{},"color":"rgb(128,195,170)","size":1.0},{"source":"6","target":"18","id":"26","attributes":{},"color":"rgb(112,189,159)","size":1.0},{"source":"6","target":"15","id":"20","attributes":{},"color":"rgb(91,181,146)","size":1.0},{"source":"16","target":"1","id":"43","attributes":{},"color":"rgb(146,211,192)","size":1.0},{"source":"6","target":"13","id":"18","attributes":{},"color":"rgb(61,160,116)","size":1.0},{"source":"16","target":"10","id":"44","attributes":{},"color":"rgb(187,228,219)","size":1.0},{"source":"12","target":"2","id":"33","attributes":{},"color":"rgb(99,184,151)","size":1.0},{"source":"15","target":"10","id":"42","attributes":{},"color":"rgb(179,225,214)","size":1.0},{"source":"19","target":"3","id":"47","attributes":{},"color":"rgb(117,190,161)","size":1.0},{"source":"6","target":"8","id":"10","attributes":{},"color":"rgb(99,184,151)","size":1.0},{"source":"6","target":"9","id":"13","attributes":{},"color":"rgb(144,202,180)","size":1.0},{"source":"6","target":"17","id":"25","attributes":{},"color":"rgb(67,165,123)","size":1.0},{"source":"23","target":"6","id":"55","attributes":{},"color":"rgb(45,147,98)","size":1.0},{"source":"20","target":"17","id":"52","attributes":{},"color":"rgb(55,154,109)","size":1.0},{"source":"6","target":"16","id":"23","attributes":{},"color":"rgb(99,184,151)","size":1.0},{"source":"15","target":"4","id":"41","attributes":{},"color":"rgb(154,215,198)","size":1.0},{"source":"15","target":"8","id":"38","attributes":{},"color":"rgb(130,205,182)","size":1.0},{"source":"20","target":"21","id":"48","attributes":{},"color":"rgb(49,149,101)","size":1.0},{"source":"20","target":"4","id":"51","attributes":{},"color":"rgb(112,183,153)","size":1.0},{"source":"15","target":"2","id":"39","attributes":{},"color":"rgb(130,205,182)","size":1.0},{"source":"24","target":"4","id":"62","attributes":{},"color":"rgb(93,168,131)","size":1.0},{"source":"1","target":"3","id":"2","attributes":{},"color":"rgb(167,220,206)","size":1.0},{"source":"3","target":"4","id":"6","attributes":{},"color":"rgb(183,226,216)","size":1.0},{"source":"11","target":"4","id":"32","attributes":{},"color":"rgb(133,201,178)","size":1.0},{"source":"24","target":"0","id":"57","attributes":{},"color":"rgb(69,158,115)","size":1.0},{"source":"22","target":"6","id":"54","attributes":{},"color":"rgb(52,152,105)","size":1.0},{"source":"1","target":"7","id":"3","attributes":{},"color":"rgb(175,223,211)","size":1.0},{"source":"20","target":"6","id":"49","attributes":{},"color":"rgb(49,149,101)","size":1.0},{"source":"24","target":"13","id":"60","attributes":{},"color":"rgb(30,134,80)","size":1.0},{"source":"11","target":"16","id":"31","attributes":{},"color":"rgb(109,191,162)","size":1.0},{"source":"5","target":"6","id":"7","attributes":{},"color":"rgb(61,160,116)","size":1.0},{"source":"16","target":"7","id":"45","attributes":{},"color":"rgb(167,219,205)","size":1.0},{"source":"14","target":"16","id":"36","attributes":{},"color":"rgb(138,208,187)","size":1.0},{"source":"2","target":"0","id":"5","attributes":{},"color":"rgb(138,208,187)","size":1.0},{"source":"6","target":"11","id":"16","attributes":{},"color":"rgb(70,167,127)","size":1.0},{"source":"23","target":"7","id":"56","attributes":{},"color":"rgb(113,182,152)","size":1.0},{"source":"24","target":"7","id":"61","attributes":{},"color":"rgb(98,170,134)","size":1.0},{"source":"1","target":"4","id":"4","attributes":{},"color":"rgb(171,221,208)","size":1.0},{"source":"13","target":"7","id":"35","attributes":{},"color":"rgb(128,195,170)","size":1.0},{"source":"6","target":"1","id":"14","attributes":{},"color":"rgb(108,187,157)","size":1.0},{"source":"12","target":"4","id":"34","attributes":{},"color":"rgb(124,194,167)","size":1.0},{"source":"8","target":"3","id":"29","attributes":{},"color":"rgb(158,216,200)","size":1.0}]}